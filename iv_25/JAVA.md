# JVM

## 类加载

> 类加载过程

+ 加载：将.class从硬盘上加载到内存中的过程
+ 连接
  + 验证：验证字节码文件是否合法且不会破坏系统
  + 准备：对静态变量赋予默认值
  + 解析：常量池中的符号引用转换成直接引用
+ 初始化：对静态变量赋予初始值

> 类加载器

- 核心加载器：加载 Java 核心文件
- 扩展加载器：加载 ext 包下的类
- 应用加载器：加载应用服务需要用到的类，我们编写的类
- 自定义加载器：满足一些特定业务需要，在系统运行中加载或者替换一些类。比如热部署、数据加密

## 虚拟机结构

- 堆，线程共有。存放创建的对象，数组信息等
- 方法区，线程共有。存放加载的类的一些元数据
- 虚拟机栈，线程私有。存放
- 本地方法栈，线程私有。使用栈的方式存在线程使用到的方法常量，方法入口出口等信息
- 程序计数器，用来记录程序执行的位置，方便方法栈的调用

## 垃圾收集

- 引用计数法：一块专门的空间来记录引用的相互依赖关系，当一个对象不在这个地方有引用时，则可以标记清除
- 可达性分析法：通过 GCRoots 的根节点数据来链接所有对象，当一个对象无法从 GCRoots 找时，则可以被标记清除

## 垃圾回收

- 复制算法：将原本的空间中有效的对象复制到另一个空间，当前空间回收。空间浪费

- 标记-清除：对存活的对象进行标记，其他对象进行清除。碎片化空间

- 标记-整理：对存活的对象进行标记，之后将存活的对象整理到一块连续空间中，其他空间清除

- 分代回收：分为 Eden 代、Survive 代和 Old 代

  Eden 代主要保存当前一个周期内创建的新对象

  From 代保存上一次垃圾回收之后的剩余对象（不包括需要放到 Old 中的对象）

  To 作为临时存放点，在垃圾回收之后会被标记为 From 代

  Old 代存放多次垃圾回收未进行回收的数据，以及一些大对象数据

  进行一轮垃圾回收，会将 Eden 和 From 中存活的对象使用复制算法复制到 To 中。

## 垃圾收集器

最常用的两种

- Parallel Scavenge + Parallel Old 组合的垃圾回收器。用于吞吐量和 CPU 资源敏感的场景。Parallel Scavenge 是新生代回收器，采用标记 - 复制算法；Parallel Old 是老年代回收器，采用标记 - 整理算法。
- G1，分区管理。它将堆内存划分为多个大小相等的独立区域（Region），每个 Region 可以根据需要扮演新生代、老年代或空闲区域的角色。新生代采用标记 - 复制算法，老年代采用标记 - 整理算法。

## JVM调优策略

> 高并发场景

1. 增大堆内存 `-Xms`和`-Xmx`。并设置两者相等，避免频繁扩缩
2. 增大新生代占比。`-XX:NewRatio`，减少进入老年代的概率
3. 使用 G1 垃圾回收，降低 STW 的时间 `-XX:UseG1GC`
4. 调整 STW 最大时间`-XX:MaxGCPauseMillis`

> 大数据处理场景

1. 调整堆内存更大，Eden 占比更小
2. 使用 Parallel 组合垃圾回收，充分利用 CPU 多核的效率

## Eden代数据进入Old代的场景

1. Survive 内存不够

2. 对象被标记的次数过多

3. 大对象直接分配

4. ###### 空间分配担保机制触发

## Minor GC、Major GC、Full GC

**Minor GC触发条件**：

1. **Eden 区满**：当新对象无法在 Eden 区分配时触发，与 Survivor 区是否满无关。
2. **Survivor 区空间不足**：Minor GC 会将存活对象从 Eden 和 Survivor From 区复制到 Survivor To 区，若 To 区空间不足，部分对象会直接晋升到老年代

**Full GC（全堆 GC，包含 Major GC）**

1. **老年代空间不足**：对象晋升到老年代时，若老年代剩余空间不足以容纳这些对象。
2. **方法区（元空间）不足**：存储类元数据的方法区空间耗尽。
3. **空间分配担保失败**：Minor GC 前预测老年代剩余空间不足，触发 Full GC。
4. **显式调用 System.gc()**：JVM 可能（但不必然）执行 Full GC。
5. **大对象直接分配失败**：超过 `-XX:PretenureSizeThreshold` 的大对象无法直接进入老年代时

**Major GC**

通常与 Full GC 同时发生，老年代空间不足时触发

## 杂乱

> 双亲委派

为了防止，修改了一些基本的类，会被我们自定义的加载器进行加载。所以同包同名的核心java类是会一层一层往上找，找到核心类加载器去加载。只有上层的加载器加载不了，才会让下层的类加载器去加载

# JUC



# IO



# Collection

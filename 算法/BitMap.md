# 位运算

以标签系统为例（使用位运算最多只能有64个标签（一个字段64，可以使用多个字段做标签组），就是64位的数据转换为10进制，就是数据库的bigint可存储的最大的十进制数据）

**一、基本概念**：
位运算是对二进制位进行的运算，直接操作数字的二进制表示形式。在计算机中，所有的数据最终都是以二进制的形式存储和处理的，因此位运算可以高效地实现某些功能。

**二、常见的位运算操作符及其作用**：

1. 按位与（&）

   - 规则：对于每一位，只有当两个操作数的相应位都为 1 时，结果才为 1，否则为 0。
   - 示例：

   ```c
   int a = 5;  // 二进制表示为 0101
   int b = 3;  // 二进制表示为 0011
   int result = a & b;  // 结果为 0001，即十进制的 1
   ```

   - 应用：常用于屏蔽某些位，例如 `n & 0x0F` 可以将 `n` 的高 4 位清零，只保留低 4 位。
   - 标签：
     - 可以计算用户是否有对应标签的情况。
     - 可以计算两个用户相同的标签
     - 找到满足某个标签的用户

2. 按位或（|）

   - 规则：对于每一位，只要两个操作数的相应位有一个为 1，结果就为 1，只有当两个位都为 0 时，结果才为 0。
   - 示例：

   ```c
   int a = 5;  // 二进制表示为 0101
   int b = 3;  // 二进制表示为 0011
   int result = a | b;  // 结果为 0111，即十进制的 7
   ```

   - 应用：常用于设置某些位，例如 `n | 0x0F` 可以将 `n` 的低 4 位全部置为 1。
   - 标签：

3. 按位异或（^）

   - 规则：对于每一位，如果两个操作数的相应位不同，则结果为 1，如果相同，则结果为 0。
   - 示例：

   ```c
   int a = 5;  // 二进制表示为 0101
   int b = 3;  // 二进制表示为 0011
   int result = a ^ b;  // 结果为 0110，即十进制的 6
   ```

   - 应用：

     - 交换两个数的值：

     ```c
     a = a ^ b;
     b = a ^ b;
     a = a ^ b;
     ```

     - 检查两个数是否相等：`a ^ b == 0` 表示 `a` 和 `b` 相等。

4. 按位取反（~）

   - 规则：对操作数的每一位取反，即 0 变为 1，1 变为 0。
   - 示例：

   ```c
   int a = 5;  // 二进制表示为 0101
   int result = ~a;  // 结果为 1010，即十进制的 -6（考虑补码表示）
   ```

   - 应用：常用于取反某些位，例如 `~0x0F` 可以将低 4 位取反。

5. 左移（<<）

   - 规则：将操作数的二进制表示向左移动指定的位数，右边补 0。
   - 示例：

   ```c
   int a = 5;  // 二进制表示为 0101
   int result = a << 2;  // 结果为 010100，即十进制的 20
   ```

   - 应用：
     - 乘以 2 的幂次方，例如 `n << 1` 相当于 `n * 2`，`n << 2` 相当于 `n * 4` 等。
     - 用于设置特定的位，如 `1 << 3` 可以得到二进制 `00001000`，用于表示第 4 位为 1。

6. 右移（>>）

   - 规则：将操作数的二进制表示向右移动指定的位数，对于无符号数，左边补 0；对于有符号数，左边补符号位（即算术右移）。
   - 示例：

   ```c
   int a = 5;  // 二进制表示为 0101
   int result = a >> 1;  // 结果为 0010，即十进制的 2
   ```

   - 应用：
     - 除以 2 的幂次方，例如 `n >> 1` 相当于 `n / 2`（向下取整）。
     - 提取数字的某些部分，如 `n >> 4` 可以提取高 4 位。

**三、位运算的优势和应用场景**：

- 优势
  - 位运算通常比算术运算和逻辑运算更高效，因为它们直接操作二进制数据，计算机硬件可以直接执行。
  - 可以用位运算实现一些复杂的逻辑，同时代码简洁。
- 应用场景
  - 数据压缩和标记：如使用位图存储多个布尔值，节省空间。
  - 权限控制：用不同的位表示不同的权限，通过位运算来设置、检查和清除权限。
  - 哈希算法：某些哈希算法会使用位运算来混淆和扩散数据。

**四、注意事项**：

- 位运算操作的是二进制位，结果取决于操作数的二进制表示，因此需要对二进制有清晰的理解。
- 在使用有符号数时，要注意右移操作可能会保留符号位，导致结果与预期不符。
- 不同编程语言对于位运算的优先级和行为可能略有不同，需要注意运算符的优先级和使用括号明确运算顺序。

通过合理使用位运算，可以在性能和空间上优化程序，特别是在需要处理大量数据和对性能要求较高的场景中





# 位运算在标签中的应用

以下是使用 bitmap 存储标签时常见的一些 `SELECT` 查询方式：

**一、检查单个用户是否具有某个特定标签**：
假设我们使用 MySQL 存储用户的标签信息，并且使用 `BIGINT` 数据类型存储 `bitmap`。

```sql
-- 检查用户 ID 为 1 的用户是否具有第 3 个标签（从 0 开始计数）
SELECT (tag_bitmap & (1 << 3)) > 0 AS has_tag_3
FROM users
WHERE user_id = 1;
```

**代码解释**：

- `tag_bitmap & (1 << 3)`：使用位与操作 `&` 将 `tag_bitmap` 和 `1 << 3`（即第 3 位为 1，其余位为 0 的数）进行按位与操作。
- `(tag_bitmap & (1 << 3)) > 0`：如果结果大于 0，则说明该用户具有第 3 个标签。

**二、找出具有特定标签的所有用户**：

```sql
-- 找出具有第 5 个标签（从 0 开始计数）的所有用户
SELECT user_id
FROM users
WHERE (tag_bitmap & (1 << 5)) > 0;
```

**代码解释**：

- 此查询使用 `WHERE` 子句中的位与操作筛选出 `tag_bitmap` 中第 5 位为 1 的用户，即具有第 5 个标签的用户。

**三、找出具有多个特定标签的用户（交集）**：
假设我们要找出同时具有第 2 个和第 3 个标签的用户：

```sql
-- 找出同时具有第 2 个和第 3 个标签的用户
SELECT user_id
FROM users
WHERE (tag_bitmap & ((1 << 2) | (1 << 3))) = ((1 << 2) | (1 << 3));
```

**代码解释**：

- `(1 << 2) | (1 << 3)`：生成一个 `bitmap`，其中第 2 位和第 3 位为 1。
- `tag_bitmap & ((1 << 2) | (1 << 3))`：将用户的 `tag_bitmap` 与生成的 `bitmap` 进行位与操作。
- `(tag_bitmap & ((1 << 2) | (1 << 3))) = ((1 << 2) | (1 << 3))`：只有当用户的 `tag_bitmap` 中第 2 位和第 3 位都为 1 时，结果等于 `(1 << 2) | (1 << 3)`，筛选出同时具有这两个标签的用户。

**四、找出具有至少一个特定标签的用户（并集）**：
假设我们要找出具有第 4 个或第 5 个标签的用户：

```sql
-- 找出具有第 4 个或第 5 个标签的用户
SELECT user_id
FROM users
WHERE (tag_bitmap & ((1 << 4) | (1 << 5))) > 0;
```

**代码解释**：

- `(1 << 4) | (1 << 5)`：生成一个 `bitmap`，其中第 4 位或第 5 位为 1。
- `(tag_bitmap & ((1 << 4) | (1 << 5))) > 0`：使用位与操作，如果结果大于 0，说明用户至少具有第 4 个或第 5 个标签中的一个。

**五、找出具有某些标签但不具有另一些标签的用户（差集）**：
假设我们要找出具有第 6 个标签但不具有第 7 个标签的用户：

```sql
-- 找出具有第 6 个标签但不具有第 7 个标签的用户
SELECT user_id
FROM users
WHERE (tag_bitmap & (1 << 6)) > 0 AND (tag_bitmap & (1 << 7)) = 0;
```

**代码解释**：

- `(tag_bitmap & (1 << 6)) > 0`：筛选出具有第 6 个标签的用户。
- `(tag_bitmap & (1 << 7)) = 0`：筛选出不具有第 7 个标签的用户。

**六、找出具有最多标签的用户**：
在 MySQL 中，你可以使用 `BIT_COUNT` 函数（从 MySQL 8.0 开始）来计算 `bitmap` 中 1 的数量：

```sql
-- 找出具有最多标签的用户
SELECT user_id, BIT_COUNT(tag_bitmap) AS tag_count
FROM users
ORDER BY tag_count DESC
LIMIT 1;
```

**代码解释**：

- `BIT_COUNT(tag_bitmap)`：计算 `tag_bitmap` 中 1 的数量。
- `ORDER BY tag_count DESC`：按标签数量降序排序。
- `LIMIT 1`：只取第一个结果，即具有最多标签的用户。

**七、找出具有特定数量标签的用户**：
假设我们要找出具有 3 个标签的用户：

```sql
-- 找出具有 3 个标签的用户
SELECT user_id
FROM users
WHERE BIT_COUNT(tag_bitmap) = 3;
```

**代码解释**：

- `BIT_COUNT(tag_bitmap) = 3`：筛选出 `tag_bitmap` 中 1 的数量等于 3 的用户。

这些查询利用了位运算和 `BIT_COUNT` 函数（如果可用），可以有效地查询使用 `bitmap` 存储的标签信息。在使用 `bitmap` 存储时，要根据具体的数据库系统和版本，合理使用相应的函数和操作符，以实现所需的查询逻辑。同时，要注意 `bitmap` 的长度限制，对于需要存储更多标签的情况，可能需要使用更大的数据类型或多个 `bitmap` 字段。

在实际应用中，还可以根据不同的业务需求和系统架构，对这些查询进行调整和扩展，以实现更复杂的标签筛选和用户分组功能。



[解读bitmap](https://juejin.cn/post/6844903769201704973)
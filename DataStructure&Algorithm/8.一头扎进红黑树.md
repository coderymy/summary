# 理论

后期会重新记录这一章,红黑树我这种智商不是一天能学会的

**特性**
1. 满足基本的平衡二叉查找树
2. 根节点是黑色的,且叶子节点是黑色的不存储数据的NIL
3. 任何相邻的两个节点不能都是红色
4. 从任意节点到叶子节点包含相同的黑色节点

近乎平衡,所以查询、插入、删除的操作的时间复杂度都是O(log2^n)


# 实现

红黑树的插入、删除是有固定步骤的,所以其实实现起来很有规章

首先理解两个概念

**左旋**
![](https://img.jbzj.com/file_images/article/201901/2019110153603213.gif?2019010153616)

1. 旋转节点的右节点的左子节点变成旋转节点的右节点
2. 旋转节点的右节点变成根节点,旋转节点变成根节点的左节点

**右旋**
![](https://img.jbzj.com/file_images/article/201901/2019110153626752.gif?2019010153637)

1. 旋转节点的左节点的右子节点变成旋转节点的左节点
2. 旋转节点的左节点变成根节点,旋转节点变成根节点的右节点


红黑树的插入、删除操作就是通过旋转来维护红黑树的四条特性的

## 插入

学不会了,红黑树先搁一下这块插入删除的逻辑处理,😭😭😭


步骤:<br>
1. 直接将节点按照平衡二叉树的查询结果插入
2. 将节点着色为红色
3. 通过旋转和重新着色来完整对红黑树的维护

```
维护红黑树的流程逻辑

插入节点为N

1. 根节点为空,则直接将N改为黑色插入即可
2. N的父节点为黑色,不做其他修改
3. N的父节点为红色---N的叔叔节点为红色  
    + 将N的父节点和叔父节点的颜色都改为黑色
    + 若祖父节点是跟节点就将其改为黑色，否则将其颜色改为红色
    + 并以祖父节点为插入的目标节点从情况1开始递归检测
4. N的父节点是红色---N的叔叔节点是黑色,且N和N的父节点在同一边(父节点在祖父节点的左节点,该节点在其父节点的左节点)
    + 以父节点为祖父节的左儿子为例，将父节点改为黑色，祖父节点改为红色，然后以祖父节点为基准右旋
5. N的父节点是红色---N的叔叔节点是黑色,且N和N的父节点不在同一边
    + 以父节点为祖父节点的左儿子为例。以父节点为基准，进行左旋，然后以父节点为目标插入节点进入情况4进行操作。
```

## 删除

首先:
删除的节点有两个儿子时候可以转换成只有一个儿子.即将左节点的最大子树移到右节点上去(或者反过来)

```
删除节点维护红黑树


1. N为红色节点时。直接删除N，用它的黑色儿子代替它的位置。
2. N为黑色节点，且父节点为红色。直接删除N，用它的儿子节点代替它的位置，并将该儿子节点改为黑色。
3. N为黑色节点，且父节点为黑色。我们之间删除N，用它的儿子节点代替它，该儿子节点成为N'，将N’的颜色改为黑色。(N’的兄弟节点和兄弟节点的2个儿子都为黑色。交换兄弟节点和父节点的颜色即可。)
```



# 附

**1. 为什么红黑树是近似平衡的呢**

首先将红色节点全部去除,就会发现黑色节点(从根节点到所有叶节点的路径一样长)会组成一个平衡的二叉树,这个二叉树的高度不会超过完全平衡二叉树的(log2^n)

那么即使加上红色节点,高度也不会超过(2log2^n).所以效率相对于而言是很高的,非常趋向于平衡

![](https://static001.geekbang.org/resource/image/7e/ed/7e6ecc308fe44120f30de809822215ed.jpg)


**2. 所以为什么红黑树这么火呢,为什么不使用别的树形结构而使用红黑树呢,红黑树比较平衡二叉树的优点在哪**

1. 为了提高链表的查询效率,所以提出了树形结构
2. 为了防止树形结构在极端情况下变成一条链状结构,所以需要平衡二叉树的支持
3. 平衡二叉树在插入和删除操作上会很消耗资源,所以进化成了近乎平衡的红黑树




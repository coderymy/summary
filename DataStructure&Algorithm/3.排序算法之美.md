# 排序算法之美

[排序算法动态图](https://visualgo.net/en/sorting)



先来总结下各个排序的代码实现的特点

> 冒泡排序:
> 1. 循环处理数组数据
> 2. 比较相邻两个数值的大小,如果不是顺序的就交换位置
> 3. 直到一轮操作下来没有交换位置的操作为止

> 插入排序:
> 1. 循环遍历数组
> 2. 比较循环的值和它前面的那个值的大小,如果小于前面的值就交换位置,继续进行与前面的值比较,直到前面没有值
> 3. 循环完所有数组元素结束

> 堆排序:
> 1. 按照堆的特点构造一个堆
> 2. 再将堆数据按照从左到右取出来

> 归并排序
> 1. 先将数据拆分成一个一个单独的信息
> 2. 然后将两个排好序的子序列合并成一个有序序列

> 快速排序
> 1. 遍历选择一个基准值
> 2. 判断数据小于基准值放在左边,大于基准值放在右边
> 3. 在循环选择基准值持续上述操作


# 如何分析**排序算法**

## 排序算法的好坏 
从这几个方面来衡量
+ 最好情况、最坏情况、平均情况时间复杂度
+ 时间复杂度的系数、常数、低阶
+ 比较次数和交换（或移动）次数

## 排序算法的内存消耗 

可以使用空间复杂度来衡量

原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法.

## 排序算法的稳定性 

这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

```
我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。

经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。
```
稳定性有什么作用呢

问题:比如10万条订单数据,需要按照金额从小到大排序,订单金额一致的按照订单创建时间排序

解决一:使用两步排序的方法,先使用金额排序,在使用时间排序

解决二:使用稳定性的排序算法,先按照订单下单的时间排序,排序完成之后再按照订单金额排序.**稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。**.为什么说这种方案比上一种好呢,因为一般我们存储在数据库的数据都有时间来进行排序,所以其实第一步先进行时间排序,真实的场景并不会变更很多数据,所以对资源的消耗要小一些.



# 冒泡排序

原理:
+ 冒泡排序只会操作相邻的两个数据。
+ 如何左边大于右边,就进行更换位置.直到没有需要更换的为止


[](https://pic1.zhimg.com/v2-43dc4f02286be372415bec478a227940_b.webp)

代码实现
```java
    public static void main(String[] args) {
        SortTest sortTest = new SortTest();
        int[] array = {
                4, 2, 5, 1, 6, 3
        };
        System.out.println("开始时array:");
        sortTest.printArray(array);
        sortTest.bubbling2(array);
        System.out.println("结束时array:");
        sortTest.printArray(array);
    }


    public void bubbling(int[] array) {
        int count = 0;
        //冒泡排序
        System.out.println("开始排序");
        while (true) {
            //截止条件是顺序不进行更换
            boolean flag = false;
            for (int i = 0; i < array.length - 1; i++) {
                count++;
                if (array[i] > array[i + 1]) {
                    int tmp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = tmp;
                    flag = true;
                }
            }
            if (!flag) {
                break;
            }
        }
        System.out.println("执行次数：" + count);
    }

    public void printArray(int[] array) {
        for (int a : array) { System.out.print(a + ","); }
    }
    
    //优化点
    //1. 每轮执行结束之后，最后都会有一个最大的值会固定为止，比如253614。第一轮执行完成之后6就会被固定到最后的位置，第二轮执行完成之后5就会固定到除了6之外最后的位置。所以比较次数，一次会比一次少。所以可以优化成以下情况
    //2. 按照上面说法，最大执行的次数就是数组大小的次数。
    public void bubbling2(int[] array) {
        int count = 0;

        for (int i = 0; i < array.length; i++) {
            boolean flag = false;
            for (int j = 0; j < array.length - i - 1; j++) {
                count++;
                //-i是因为优化点
                //-1是因为数组最后一个元素没有其他元素可以与他比较了
                if (array[j] > array[j + 1]) {
                    int tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                    flag = true;
                }
            }
            if (!flag) {
                break;
            }
        }
        System.out.println("执行次数：" + count);
    }
```


特性:
1. 冒泡排序是原地排序算法
   冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
2. 冒泡排序是稳定的排序算法
   在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
3. 时间复杂度
   最好情况(1,2,3,4,5,6),时间复杂度是O(n)<br/>
   最坏情况(6,5,4,3,2,1),时间复杂度是O(n^2)
   平均时间复杂度O(n^2)

# 插入排序

一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。

插入排序的操作
1. 元素的比较
2. 元素的移动

原理: 借鉴至
![](https://www.cnblogs.com/nicaicai/p/12596565.html)

1. 确定到需要插入的值
2. 将值与已排序的数组进行比较
3. 值比较小就将被比较的值向后移动一次(这个时候a[j]=a[j+1])
4. 直到找到需要插入的值之后将值赋值给a[j]=val即可
代码:

```java
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

代码几个要点:
1. i从1开始比较
2. j=i-1
3. j从大向小进行--操作

特性:
1. 插入排序是原地排序算法
2. 插入排序是稳定的排序算法
3. 插入排序的时间复杂度
   最好是时间复杂度为 O(n)
   最坏是O(n^2)
   平均是O(n^2)对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作

# 选择排序
![](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

选择排序也是将数据分成“已排序”和“未排序”.每次都从未排序中获取最小的值,将其放在已排序的末尾.(交换已排序的末尾后面的数值)

特性:
1. 是原地排序算法
2. 不稳定,因为每次都会进行数据交换,会将前面的数据交换到后面,所以不稳定
3. 空间复杂度是O(1),最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)



![总结](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)



# 归并排序
上述三种排序算法时间复杂度都是O(n^2),适合小规模数据的排序.而大量数据的排序,一般会用到**归并排序**和**快速排序**

归并排序和快速排序都用到了<font color="red">分治思想，非常巧妙</font>。我们可以借鉴这个思想，来解决非排序的问题，比如：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？

归并排序,使用了分治思想和递归思想

**原理:**
1. 分解,即将一个大的数组分成两段(再将两段数组分别分成两段,直到q>=r就不就行分割了).将数组p->r分成两段p->q和q+1->r---从外到内
   ![](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)
2. 合并,将多个小数组使用如下方式进行合并.---从内到外
   ![](https://static001.geekbang.org/resource/image/95/2f/95897ade4f7ad5d10af057b1d144a22f.jpg)
   也就是比较array[i]与array[j]的大小,如果i小,就将i的值放到临时数组中并进行i+1,否则放入j进行j+1.每个小数组都进行如此操作,最终得到一个大数组

代码实现也分为两部分

```java
//TODO 分解
// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}


//合并

merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
```

特点:
1. 归并排序是稳定的排序算法
2. 时间复杂度:
   都是:O(nlogn)
   推倒较复杂,看{极客时间}(https://time.geekbang.org/column/article/41913)
3. 空间复杂度,因为创建的临时数组最多存储的就是整个数组的数量,所以时间复杂度是O(n)

# 快速排序

原理:
1. 分区,获取pivot来进行后续的排序操作
2. 排序,遍历数组所有元素,将大于pivot的放在右边,小于pivot的放在左边.并进行递归上述处理

![](https://img2018.cnblogs.com/blog/1514171/201811/1514171-20181123212307575-952364244.png)
```
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p >= r
```

```java

// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}
```

排序并获取分区点
partition()
```java
partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i
}
```

**特点:**
1. 原地
2. 不稳定
3. 递归实现O(nlogn)

# 线性排序
桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作线性排序

## 桶排序

核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

![](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg?wh=1142*705)

时间复杂度是o(n),但是如果分配的不均匀,全部放在一个桶中,时间复杂度就变成了o(nlogn)(桶内使用快排)

而且要求排序的桶之间能够有明确的大小划分.比如将100万条数据进行年龄排序,这个时候就可以分年龄段定义桶.桶内实现快排

## 计数排序

即桶排序的基础上,每个桶内不需要再进行排序.比如高考900分满分,排名,分901个桶,从0-901依次存放.这个时候在任何一个桶中分数都是一样的,考生的排名其实也是一样的

## 基数排序

比如进行手机号排序,我们知道假如两个数字“190xxxxxxxx”和“189xxxxxxxx”,那么由于第一个数字的第二位是9比8大,所以第一个数字肯定大些

针对这种情况,也就是基数排序就是先比较最后一个数字进行排序,排序完成之后再比较倒数第二位进行排序.一直到第一位进行排序.这种排序结果下来,由于最前面的排序是在最后操作的,所以最终能得到一个有序的集合

![](https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg?wh=1142*511)



# 排序算法的选择以及最优解

![](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

如何选取一个通用的排序算法呢

首先线性排序是针对特殊场景才能使用的,其次简单的排序算法(冒泡、插入、选择)时间复杂度相对于O(n^2),而快排和归并稍好些,但是归并空间消耗较高,所以我们使用最多的就是快排(Java中使用堆排序,C使用快排)

但是快排最坏情况的时间复杂度是O(n^2)如何解决呢?

## 优化快排效率

首先最坏情况出现是分区点选择不合理,每次都选择当前分区的最后一个数据.那么最理想的就是分区点选出来之后,分开的两部分数据量差不多

所以为了优化快排,这里就引入了分区选择算法

1. 三数取中法(数据量很高的时候,相对于第二种会稍微好些)
   我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。
2. 随机法
   随机获取

## 优化快排的堆栈溢出

因为快排的思想是使用递归的方式,递归就会带来堆栈溢出的可能

所以为了防止堆栈溢出,可以使用以下两点来保证
1. 设置最深递归深度.即到达最深递归深度就不允许再进行递归操作
2. 通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制.
   TODO,如何实现?

一般来说,最优的排序算法并不存在,还是需要深入业务情况来判断什么样的排序算法才是最合适的.而且每种排序算法又有自己的优化空间以及相应的风险点,所以开发的时候还是要深入理解这种排序的原理与规则才能更好的选择排序算法以及规避风险点.这也是学习数据结构与算法的根本.


#  附

**1. 为什么插入排序比冒泡排序要好**

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。
```java

冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

**2. 快排的特点**

基于分治和分区的思想

**3. O(n) 时间复杂度内求无序数组中的第 K 大元素。**
比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。

这样就可以使用快排的思想
我们选择数组区间 A[0...n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]、A[p]、A[p+1...n-1]。

注意理解下面:
**如果 p+1=K，那 A[p]就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1...n-1]区间，我们再按照上面的思路递归地在 A[p+1...n-1]这个区间内查找。同理，如果 K<p+1,那我们就在A[0...p-1]区间查找**

![](https://static001.geekbang.org/resource/image/89/91/898d94fc32e0a795fd65897293b98791.jpg)




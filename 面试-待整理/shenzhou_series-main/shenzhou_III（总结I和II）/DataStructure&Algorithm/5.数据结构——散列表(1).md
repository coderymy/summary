# 散列表(HashTable)

# 概念
散列表基于数组的实现,在数组的基础上优化了key的生成方式.

+ 散列函数:就是计算hash值的计算方法,hash(key)
+ 散列值:使用散列函数计算出来key的值就是散列值

散列函数设计的三个基本要求

1. 最终得到的hash值是一个非负整数
2. 如果key1=key2,那么hash(key1)=hash(key2)
3. 如果key1不等于key2,那么hash(key1)不等于hash(key2)---真实情况并不难满足,会出现hash冲突的情况


# 如何解决散列冲突(hash冲突)

**开放寻址法**
1. 线性探测
2. 二次探测
3. 双重散列


线性探测:

插入操作
如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。<br/>
存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br/>
查找操作
```
 在进行查找的时候,就需要增加一步.如果针对hash值没找到对应的信息,就继续往下面找,直到找到空的hash漕才认为没有这个值
```
删除操作
```
因为查找的方法,所以删除数据的时候,并不能直接将数据删除成空.这样会导致查找找不到数据

所以这个时候就只能将删除的数据进行标记为deleted状态,使相应的插入和查找操作能跳过这个值
```
如此发现其实存在很多麻烦

二次探测:

二次探测与线性探测的区别在与每次探测的步长不再是1,而是n^2.
比如第四次探测步长就是3^2

双重散列:

就是计算hash值,并不是使用一个散列函数,而是使用多个散列函数,如果第一个散列值的数值出现了hash冲突,就使用第二个的散列函数计算的hash值


不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。

为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。

装载因子的计算公式是：散列表的装载因子=填入表中的元素个数/散列表的长度

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。


**链表法**

很简单理解,就是每个hash槽都对应外挂一个链表结果,如果发生hash冲突,就将数值顺序存放在对应外挂的链表上

![](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)

相应的查找操作就需要多加一步在链表上进行遍历的操作


**当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。**

**基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。**

# 如何设计散列函数


1. 函数的设计不能太复杂,太复杂会过于消耗性能
2. 尽量分布均匀,避免过多的hash冲突出现

最常用的一般都是将key值进行ascll码累加,累加之后与数组的长度进行取模运算,将结果放在最终的数组的对应在下标下

# 装载因子过大如何处理

```
散列表的装载因子=填入表中的元素个数/散列表的长度
```
所以装载因子的大小决定hash冲突的概率.

为了避免装载因子过大,所以我们需要设置一个阀值进行数组的动态扩容


# 如何避免低效的扩容

扩容需要的操作
1. 申请一块更大的空间(具体按照函数设定,一般为1.5倍)
2. 将原来的数组的数据转移到新的空间

第二步操作是十分耗时的.为了减少这种耗时的操作.一般有如下的算法思路来实现动态扩容

> 动态扩容优化:
> 
> 不进行一次性扩容,而是触发到需要扩容的阀值的时候,只是申请一块空间,将新的数据插入这个空间.然后并不一次性将原始数据复制过来
> 
> 而是在之后的每次数组插入的时候一点点复制原有的数组
> 
> 这个时候进来的查询操作,首先遍历新数组,再遍历老数组



# hashMap实现的散列表

1. 初始大小<br/>
   默认初始大小是16
2. 装载因子和动态扩容<br/>
   最大装载因子是0.75.即表示元素超过设置的16*0.75之后就会进行扩容操作
3. 散列冲突解决办法<br/>
   使用数组加链表的方式,在jdk8之后,链表进行了优化,链表长度在8时进行链表与红黑树之间的转换以提高查询等操作的性能
4. 散列函数
   ```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
   ```


**Redis中的hash,set,hset,都是散列表实现，他们的动态扩容策略是同时维护两个散列表，然后一点点搬移数据**


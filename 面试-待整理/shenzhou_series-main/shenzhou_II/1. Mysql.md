首先本文具有的标签性质是：锁、间隙锁、乐观锁、悲观锁、事务、隔离级别、MVCC、索引、B+树、explain关键字、主从复制等。

建议从上往下一点一点看，知识点之间都是相互关联的，顺序看有助于理解。

# 锁机制

## 按照锁范围分类

### **全局锁**

一般只有在进行库的逻辑备份的时候才会使用

### **表级锁**

> 表锁

表级锁分为读锁和写锁。使用关键字`lock tables t1 read/write`加锁，使用`unlock tables`解锁（无需指定表）。或者在该线程的链接断开之后自动释放锁

锁定的表的操作其他线程就无法进行了

> MDL锁

MDL锁也是一个在表上操作的锁

在进行表字段的增删改查的时候，上读锁，在事务结束的时候释放

在进行表结构变更/索引变更的时候，上写锁，在事务结束的时候释放

*只要有写锁的存在，其他的线程的操作都是会阻塞的*。也就是说在修改表结构，创建表索引的时候，会影响其他线程的一切操作。

### **行级锁**

行锁是由各自的引擎实现的，例如InnoDB有行锁，MyIsam没有行锁。

在进行数据变更的时候上锁，在事务结束的时候自动释放锁

多个线程对同一行进行修改就会导致需要等待一个线程的锁释放(事务结束)才能进行修改

> 死锁

行锁很容易造成死锁

例如

1. 线程1修改了id=1的数据，上锁
2. 线程2修改了id=2的数据，上锁
3. 线程1想要修改id=2的数据，但是在锁中，所以等待线程2的释放
4. 此时线程2又想要对id=1的数据修改，所以等待线程1的释放
5. 此时就造成了死锁（你俩搁着闹呢）

解决方案：

1. 等待其中一个线程的链接请求超时时间过了，就会自动断开链接从而自动释放锁

2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑（默认开启）

   问题：就是每当一条数据被锁住的时候，就要检测下别的依赖这条数据的线程是否存在被锁住的情况。对性能有很高的损耗

   如果对业务清晰不会出现类似上述的死锁情况，可以将参数改为off从而提升性能

### 间隙锁

一个很特殊的存在，是为了解决幻读问题（即，我以为我修改了全部的十条数据，其实在我修改期间又新增了第十一条数据）

例如：update t1 set record="蛋炒饭" where num<10;

虽然num<10的只有三条数据（num=2,num=5,num=7），但是在这个期间如果新增了数据就会造成幻读的情况。所以这个时候上锁的其实是

+ num=2的记录行锁
+ num=5的记录行锁
+ num=7的记录行锁
+ (-无穷大,2)(2,5)(5,7)(7,10)这四个范围的间隙锁



## 按照锁本质分类

|          | 乐观锁                                                       | 悲观锁                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原理     | 认定不会出现数据冲突，<br>所以只是维护一个版本号，<br>在业务处理结束的时候验证下版本号是否正确（即该业务处理期间有没有数据变更） | 认定业务处理期间一定会发生数数据变更冲突<br/>在业务处理之前先获取到锁<br/>要求别的线程必须等待锁的释放才能继续该逻辑 |
| 实现方式 | 业务实现<br>1. 获取该条数据的版本号<br>2. 业务操作<br>3. 业务处理完之后判断该条数据的版本号是否变更，如果变更就进行回滚等操作 | Mysql实现，在进行select操作的时候加上`for update`关键字，在当前事务结束之后自动释放锁。<br>别的线程在事务结束之前进行该条记录的变更都会进入阻塞状态，直到锁的释放 |



# 事务

## 四大特性

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/0s9ncl.jpg)

|              | 原子性**A**tomicity                                          | 一致性**C**onsistency                                        | 隔离性**I**solation                       | 持久性**D**urability                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------- | ------------------------------------------------------------ |
| 解释         | 事务是最小的单位,不允许进行分割,<br>                         | 事务执行之前和执行完成之后这个<br>业务数据的状态是一致的（不会出现中间状态的数据） | 多个事务执行期间对数据的修改不会相互影响  | 事务执行完成之后,对数据的修改会保存在数据库中,不会再有回滚的操作出现 |
| 详细解释     | 即**事务所执行的操作要么都完成要么都失败**                   | 这个一致性其实很多概念解释的都很模糊,比如<br/> 1. ~~事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。~~<br/> 2. ~~一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。~~<br/>其实这些说法也对,但是没有说到点子上去<br/>就拿上面转账来说,事务的一致性**其实就是多个事务看这个总钱数,无论是这个事务之前前还是执行后,都是一样的.也就是别的事务不会看到这个事务执行期间的中间状态(中间状态从A扣钱和给B加钱肯定是有个顺序的,这个时候钱的总数肯定的少了或者多了的)**<br/>那么就有的人会问了,那么这个概念不是和原子性一致了嘛<br/>原子性关注于状态,要么都成功要么都失败<br/>而一致性关注于数据,保证事务执行期间的这个数据不会超脱于业务之上 | 多个事务执行期间,对同一条数据不会产生影响 |                                                              |
| 实现方式     | 使用undo log实现                                             | 一般由代码层面来保证                                         | 通过加锁和MVCC去实现的                    | 使用的redo log实现的                                         |
| 实现方式详解 | 1. 在操作任何数据之前,都先将数据备份到另一个地方(这个地方称之为undo log)<br/>2. 然后就行数据修改<br/>3. 如果出现异常或者执行了rollback操作,系统就使用undo log中的数据将数据恢复到事物执行之前的状态 |                                                              |                                           | 1. 操作任何数据的时候,都将操作之后的数据进行备份到一个地方(这个地方就叫做redo log)<br/>2. 事务提交之前将redo log持久化<br/>3. 如果 系统出现崩溃则可以直接使用redo log恢复数据 |

## 事务并发的问题

+ **脏读（Dirty read）:** (读取了后来回滚的操作)事务A读取了事务B未提交的数据修改,事务B又回滚了(读了不该读的数据)
+ **幻读（Phantom read）:** (我以为我读取了全部)事务A读取了全部学生进行操作,结果事务B又加了学生(幻想自己读了所有)
+ **不可重复读（Unrepeatableread）:**(我读取的数据被修改了)事务A读取的数据被事务B修改并提交了(同一个事务读的两次结果不一样了)与幻读的区别在与幻读针对新增和删除.不可重复度在于修改

理解起来很好理解,就是容易记混,哈哈哈

## 隔离级别

|                                                    | 读未提交                                 | 读已提交                                                     | 可重复读                                                     | 串行化               |
| -------------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- |
| 英文及简写                                         | Read UnCommited                          | Read Commited（RC）                                          | Repeatable    Read（RR）                                     | Serializable         |
| 概念                                               | 别的事务可以读到这个事物未提交的数据变更 | 该事务的数据变更只有在提交之后才能被别的事务读取到（**但是在一个事务中两次获取的数据可能是一样的**） | 在一个事务的过程中每次获取的数据都是一样的（即使有别的事务修改了数据并提交了） | 所有事务都是依次执行 |
| 避免的问题<br>（重复读、脏读、幻读）               | null                                     | 脏读（MVCC解决可重复读问题）                                 | 脏读和重复读                                                 | 所有                 |
| 数据库默认                                         |                                          | oracle默认                                                   | mysql默认                                                    |                      |
| 备注                                               |                                          | MVCC解决可重复读问题                                         | 为了解决**可重复读**的问题，Mysql使用了MVCC的方式。为了解决**幻读**的问题，Mysql使用了间隙锁。在该隔离级别上都有体现 |                      |
| 生成readView的时机（MVCC作用在RR和RC上不同的原因） |                                          | 事务中每次select都会生成一个readView                         | 每个事务创建一个readView                                     |                      |

在启动参数中设置`transaction_isolation`即可配置事务隔离级别,查看当前隔离级别` show variables like 'transaction_isolation'`默认隔离级别是“可重复读”

## MVCC

> 大体总结一句话描述什么是MVCC：
>
> 为了解决事务的问题“不可重复读”，MVCC相当于有一个版本号的概念，在事务开启的时候有一个快照，后续每次进行查找的时候，都会基于“版本号”进行回退查找历史更改记录。直到获取到<=这个版本号的数据。这样在该事务中获取的数据都会是一样的，不会因为别的线程修改而导致前后两次获取/修改的数据不一致

### 为什么要使用MVCC？（Why）

Multi-Version Concurrency Control，多版本并发控制。

由上面MDL锁可知

| 未使用MVCC | 读操作 | 写操作 |
| ---------- | ------ | ------ |
| 读操作     | 不阻塞 | 阻塞   |
| 写操作     | 阻塞   | 阻塞   |

只要涉及写操作的都会出现阻塞的情况。MVCC的机制就可以将上述MDL锁变成如下

| 使用MVCC | 读操作 | 写操作 |
| -------- | ------ | ------ |
| 读操作   | 不阻塞 | 不阻塞 |
| 写操作   | 不阻塞 | 阻塞   |

也就是只有多个线程进行写操作的时候才会出现阻塞的情况。由此大大提升了数据的操作性能



### 什么是MVCC？（What）

> 首先理解几个概念
>
> + **当前读**：悲观锁状态下，有些业务要求的就是最新的数据。例如像select lock in share mode(`共享锁`), select for update ; update, insert ,delete(`排他锁`)这些操作都是一种当前读。他们操作的都得是最新的数据。
>
> + **快照读**：在非串行化的隔离级别下`不加锁`的select操作就是快照读。（串行化时快照读退化成当前读，毕竟执行严格按照顺序来了，也就没有之前数据一说了）这也就是为什么能够解决`可重复读`的问题的根由。

综上所述：为了解决提升数据库操作性能->解决有写锁在的情况下的读操作阻塞问题->快照读解决`可重复读`的问题->所以就衍生出了MVCC这种机制

> 这里有几个考察点
>
> 1、快照读只有在隔离级别是RR和RC的时候才是快照读，在串行化的情况下会变成当前读。在读未提交的级别下没有锁的概念，无所谓什么快照读了
>
> 2、当前读是指增删改和加锁的读。都是针对悲观锁的行锁。快照读一般针对我们业务用的最频繁的不加锁的select操作

### MVCC的实现原理

> 再有几个概念理解下
>
> + 三个隐式字段
>   + **`DB_TRX_ID`**
>     6byte，最近修改(`修改/插入`)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
>   + **`DB_ROLL_PTR`**
>     7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
>   + `DB_ROW_ID`
>     6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以`DB_ROW_ID`产生一个聚簇索引
>
> + undolog（区别于redolog）
>
>   会在每条DML语句都会生成一条相反的DML语句（比如delete就会生成一条insert语句）这个相反的语句会用在进行数据回滚等操作。undolog中记录的就是这种语句以及其一些基本信息（事务id、版本号等）
>
>   + Insert undo log ：涉及insert操作，回滚使用
>   + update undo log：涉及update、delete操作，回滚和快照读使用
>
> + Read View（读视图）：事务在执行快照读的那一刻生成的数据库系统的一个快照
>
>   作用：是为了能确定在版本链（undolog组成的链表）要选择的是哪个记录
>
>   其中记录的数据：
>
>   | 参数           | 描述                                           | 举例 |
>   | -------------- | ---------------------------------------------- | ---- |
>   | m_ids          | 生成该视图时所有活跃的<br>（未commit的）事务ld | 1、3 |
>   | min_trx_id     | m_ids中最小的事务id                            | 1    |
>   | max_trx_id     | 生成该视图时，<br>事务id分配器下个生成的id     | 4    |
>   | creator_trx_id | 生成该视图的事务id                             | 2    |

**哪些版本可以被访问到（commit的事务可以访问）**

   1. 如果版本链中trx_id有=creator_trx_id，可以。就使用这条undolog（我本身进行的操作）
   2. trx_id<min_trx_id，可以。说明trx_id肯定是提交了的id了
   3. trx_id>max_trx_id，不可以，相当于该trx_id是创建视图之后的id，不能读取
   4. min_trx_id<=trx_id<=max_trx_id且m_ids.isNotContains(trx_id)，可以，因为在m_ids中的事务是活跃的也就是没有commit的事务。

**MVCC实现步骤**

第一步：根据进行的DML操作生成undolog，使用其中的`DB_ROLL_PTR`来组成版本链

第二步：当启动一个事务之后，进行了快照读，则根据上述`哪些版本可以被访问到`的条件进行生成对应的`readView`

第三步：在进行CRUD的时候，根据readView可以判断出版本链中的哪条数据可以被当前事务读取到从而确定被CRUD的数据最终的状态是什么样的

   ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/u1zLsy.png)

### MVCC在RR和RC中的区别

**生成ReadView的时机不同**

RR是在一个事务中每次进行select操作的时候就生成一个readView。（如果两个select操作之间有提交的事务，那么第二次select的版本链就不一样了）

RC是在事务创建的时候针对这个事务生成一个readView（所以每次进行select的时候都是同一个）

# 索引

## B+树

二叉树、平衡二叉树、AVL树、哈夫曼树、红黑树、B-树、B+树

讲索引必讲B+树，讲B+树就必得将整个树形结构回顾一遍

|      | 二叉树                   | 平衡二叉树（AVL树）      | 满二叉树<br>与完全二叉树                                     | 红黑树 | B-树（B树） | B+树 |哈夫曼树|
| ---- | ------------------------ | --------------------- | ------------------------------------------------------------ | ------ | ---- | ---- |---|
| 特点： | 每个节点最多有两个子节点 | 每个子树左右子树高度差不超过1 | 满：每层都是满的<br>完全：将满的从右到左<br>、从下到上删除一部分节点 | 1. 叶子节点不存储数据<br>2. 根节点黑色，叶子节点黑色<br/>3. 从一个节点到该节点的所有子孙节点都包含同样的黑节点数 | 一个节点可以有多个元素 | 在B-树的基础上所有叶子节点都是使用指针相互连接的 | 两个孩子节点的值之和是根节点的值 |
|  |  |  | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/BWlmNA.png) | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/hIsQyV.png) | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/B树.png) | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/Bplus树.png) |  |

B树：相对于其他树结构，B树每个节点可以存储多个元素

B+树：相对于B树，B+树叶子节点之间使用指针相互关联

## 页

我们使用的操作系统从磁盘中获取数据是按照页（4kb）获取的，mysql从磁盘中获取的页是16kb

页的构成：

1、**用户数据区域**：也就是真实进行数据存储的数据区，使用链表结构存储

2、**页目录**：类似于书本的目录系统，简化查询操作提高查询销量

3、**页头**：其中有前后指针，也就是导致我们可以有双向的指针来获取前后的范围数据页

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/RYVUSZ.jpg)

页是一种数据结构，使用这种数据结构有以下特点

1、有前后指针方便进行上下页的获取

2、有页目录，提升用户数据区域的查询速率



## 索引结构

下面就相当于是一个<font color='red'>主键索引(聚簇索引)</font>

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/5JsmaE.jpg)

总结:

<font color='red'>B+树的非叶子结点就是所有页数据构成的一个树结构</font>

<font color='red'>B+树的叶子结点,存储的就是各个页的数据信息,页与页之间使用双向链表相互连接</font>

所以这里的查询操作就变成了

1. 首先去页构成的目录中使用二分查找到需要获取的页
2. 从磁盘中取出页
3. 在页目录中找到数据区域分配的组信息
4. 在数据区域找到对应的数据

## 聚簇索引和非聚簇索引

聚簇索引一般是我们的主键索引，也就是主键id构成的一个索引结构。这个索引结构根节点的页就是对应的那条记录所在的页的数据区域（1 小黄 男 22,2 小红 女 23）

非聚簇索引：就是后续我们建立的索引，这种索引结构的叶子节点其实是其对应的主键id（22 1,23 2）。再使用获取到的这个主键id去回表来获取整个记录数据

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/A6ycRk.jpg)

## 哈希索引

也就是使用hash算法,使用链表的方式解决hash冲突,来定位到需要查询的结果信息

支持hash的引擎有MEMORY(这里需要谷歌)，其他的引擎都通过各自的方式去支持hash方法。如InnoDB有一套自适应hash算法，内部实现还是采用了BT的方式，可以理解为BT索引的索引

设置hash索引是否生效:`set global innodb_adaptive_hash_index=off/on`

hash索引虽然使用hash算法的查询销量较高,但是有很多弊端,所以一般不建议随意使用

+ 不支持范围查找
+ 不支持查询排序
+ 不支持模糊查找



## Explain

目的就是为了检查查询语句的索引命中情况，从而来进行索引优化或者查询条件的优化

下面对几个重要的参数进行解释

1、**select_type**，select子句的查询类型，主要用来在进行子查询或者合并查询的时候区分进行的哪条查询

+ **Simple**：普通情况，未使用子查询或者union查询（合并查询结果数据使用）

+ **primary**：子查询的最外层查询/union最前面的那个查询

+ **UNION**：合并的后面那个子句

  ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/Wi0d84.png)

+ dependent union：第二个union的查询结果依赖于第一个查询结果

+ union result：合并的操作

+ subquery：子查询中的第一个select，结果不依赖外部

+ dependent subquery：子查询中的第一个select，结果依赖外部

+ DERIVED：

+ UNCACHEABLE SUBQUERY

2、<font color="red">**type**</font>

+ **ALL**：该操作进行了全表遍历

  ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/h1dbYr.png)

  出现的情况

  + 查询的操作就是要查询出来全表的所有数据，比如id>0
  + 查询的操作字段没有索引，比如operator='小红'
  + 查询的操作字段有索引，但是没有命中，比如first_class=1（不符合最左前缀原则）

  **这种ALL的操作很耗时，需要优化**

+ **index**：遍历了索引树，但是没有回表。效率要比ALL高很多，因为回表的消耗会很大

  ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/dXYRZf.png)

+ **range**：基于索引的范围查找，也就是在索引上进行了范围查找

  `<`，`>`,`between`,`in`,`or`等操作

+ **ref**：命中索引查找，但是查找值不唯一。

+ **ref_eq**：命中了唯一索引/主键索引，查找值唯一

+ **const**：命中主键索引

3、**possible_keys**，表示命中的索引（有可能会命中多个，比如idx_orderNo，idx_orderNo_num）等

4、**Key**，表示真正使用的那个索引，必然在possible_keys其中一个

5、**key_len**，一般表示索引列的类型长度

6、<font color="red">**rows**</font>，表示查询到目标值需要遍历的数据量

7、ref，表示哪些列、常量被来用来查询索引上的值

8、filtered，TODO查了很多情况说这个是目标行数占检索总行数的百分比。但是好像不太多，目前还没理解为什么。

9、**Extra**，这个值还没理解，经过实战发现网上说的好多都是错的，所以还没总结，后续补充





# sql语句执行流程



# 主从复制





# 常见Q&A

## 事务

## 索引

### 1. 为什么使用B+树作为索引的数据结构而不使用hash索引

> 都知道mysql索引使用的数据结构是B+树,那么就需要先了解B+树的相关原理和使用方式
>
> **平衡二叉树**
>
> 平衡二叉树与普通的二叉树的区别在于:二叉树中任意一个节点的左右子树的高度相差不能大于 1就是平衡二叉树
>
> ![Mysql使用B+树的演变来由](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/UVqJiC.jpg)
> 二叉树(树结构查询快)->平衡二叉树(解决二叉树出现极端情况的问题)->B树(多节点,高度远小于红黑树等)->B+树(外接链表,增加范围查找的功能.非叶子结点只保存索引不保存数据节省空间)
>
> **选择B+树的原因**
>
> 1、B+树每个节点可以存储多个数据，用来实现mysql的联合索引
>
> 2、Mysql使用的B+树叶子节点之间使用双向链表，用来实现mysql的范围查找
>
> 3、类似“目录”功能,树只保存索引,下挂的链表保存数据
>
> **不选择hash的原因**
>
> 底层使用的是hash表结构，也就是key-value的结构。这样就局限于查找方式只能使用等于进行查找。否则就需要进行全表扫描
>
> 1、不支持范围查找
>
> 2、不支持查询排序
>
> 3、不支持模糊查找
>
> 4、哈希索引会出现hash冲突，这样的查询效率会变的很低从而无法实现联合索引

### 2. 为什么使用聚簇索引和非聚簇索引

1. 减少空间的使用,因为如果创建一个索引就备份所有页的数据是很消耗空间的
2. 防止进行update操作就需要对所有索引的数据进行修改

## 3. mysql索引及索引失效的各个情况

**索引在存储中的目的**:就是作为一个页构成的目录.提升获取对应页的速度(因为页存在磁盘中,所以如果全表扫描一个一个便利,就需要进行很多次的IO操作.而使用索引命中了对应的页就只需要进行一次IO操作即可)

主键索引:

1. 使用B+树维护的一个树形结构,叶子结点是对应的页.非叶子结点是页构成的一个查询目录
2. 页中包含页目录和数据区,页目录中的数据将数据区分成不同的区,方便查找



>  **最左前缀原则**

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/EFoU2r.jpg)

原理:构建的联合索引,虽然有多个字段,但是最先比较的都是最左边的字段,如果没有最左边的字段,那么就没办法在B+树上进行判断走向

即:其实创建联合索引的时候,实际上是从左向后创建索引

举例:index(a,b,c),其实会创建类似index(a),index(a,b),index(a,b,c)的索引信息.而针对只有b和c的数据查询是命中不了索引的

> **索引失效**

规则:

1. 联合索引最佳左前缀原则
2. 针对索引的任何操作都会失效(函数、计算等)`select  * from t where left(name,4)='July'
3. 多次回表会使索引失效(覆盖索引:查询的字段是索引结果信息,不需要回表就可以获取)
4. 索引上使用`!=`、`<>`、`is null`、`is not null`会失效
5. 使用like且以通配符开头会失效 `select * from t where name like '%鱼'`会失效,但是`select * from t where name like '香%'`不一定会失效
6. 索引字段是字符串,但是查询时候字符串未加‘’会失效
7. 索引字段使用`or`会失效,建议使用`union`修改

> **字符串索引**

会根据字符串的**字符规则**进行排序,可能针对不同的国家的字符顺序不一样



![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/ahaTj9.jpg)

## 4. 简单介绍下对mysql索引的理解

mysql索引包括主键索引、唯一索引、普通索引、联合索引及MyISAM引擎自带的全文索引等

InnoDB引擎默认索引的实现数据结构是B+树,为了更快命中所查询数据在磁盘中存储的是哪个页,从而减少查询时间及减少磁盘IO的次数

创建索引使用`create [索引属性] index 索引名 on 表名(索引字段(索引条件等))`

索引是一种以空间换时间的一种系统优化方式

默认创建表后会生成一个主键索引,如果不指定主键索引会自动获取表中的一个唯一索引生成主键索引,如果没有会自动虚拟出一列`rowId`作为主键索引

## 5. 为什么innoDB要使用B+树作为索引的数据结构

B+树的数据结构有如下几个特点便于mysql的搜索

+ 每个节点可以有多个值(联合索引)
+ 叶子结点包含全部的索引数据(结果查询)
+ 叶子结点使用双向指针进行指向(便于范围查找)

索引演化也是按照需求来的,具体可以看上面的索引演化过程



## 6. 为什么主键建议使用自增的,而不是uuid

+ 插入数据的时候主键会维护一个聚集索引,索引使用的是B+树实现,B+树在增加数据的时候,从中间插入的效率要远小于从末尾插入一个数据
+ 在页中存储的数据,如果从中间插入数据,会导致相应后续的数据需要”换页“的问题



## 7. 面试问你联合索引什么情况下会命中索引

+ 最左前缀原则

+ mysql也有自己校验的优化器,即如果判定走索引的消耗比全表扫描的消耗还大,就不会进行索引数据

  类似全表扫描只需要一次查询出来,但是如果使用非聚簇索引还需要进行非常多次的回表操作,这个时候就不会进行索引

## 8. 常见的面试索引命中问题

表(a,b,c,d,e),index(b,c,d),primary(a)

| 查询语句                        | 是否使用索引 | 原因                                                         |
| ------------------------------- | ------------ | ------------------------------------------------------------ |
| select * from t where b>1       | 否           | 因为需要进行多次回表操作                                     |
| select a,b,c,d from t where b>1 | 是           | 查询条件在非聚簇索引上就可以获得,不需要回表                  |
| select b from t                 | 是           | 使用索引,但是是索引扫描.<br>因为索引存储数据量要小,所以分配的页少,<br>进行数据库的IO操作次数更少 |
| select * from t order by b,c,d  | 都可         | 不使用索引(数据量少):全表扫描,需要进行重新排序<br>数据量少时直接在内存中排序速度快,如果速度量过多内存不足<br>以构成排序操作就需要进行一些规则性的操作(比如一次比较一部分))<br>使用索引:不需要排序直接使用索引排序,需要大量的回表操作 |

## 9. 什么叫做**覆盖索引**

注意,并不是一种索引类型,而是一种索引操作

即查询结果信息可以直接在索引树结束获得,不需要再进行回表来获得数据.这种查询操作就叫做覆盖索引



## 10. <font color="red">说下**索引下推**</font>

mysql5.6新增针对查询优化的

在正常进行索引查询的时候,如果还有其他查询字段,会先使用索引字段命中一部分数据,再使用其他字段进行比较.之后再进行回表操作获取整张表的数据返回

举例子

```
创建了name和age的联合索引
select * from t1 where name=“李” and age =10
mysql5.6之前:B+索引命中name->搜索->查找到多个结果->多个结果回表->回表结果判断age=10的返回
mysql5.6之后:B+索引命中name->搜索->查找到多个结果->判断该次索引结果的age是否=10->符合条件的结果进行回表并返回
```

也就是说,mysql针对联合索引的查找字段,增加了在非聚簇索引获得值之后判断另一个参数是否满足条件这一步再进行回表操作



## 11. 简单介绍下explain的使用

查看上文



## 12. 普通索引和唯一索引

区别: 唯一索引指定的字段保证唯一性

性能分析:

**查询效率**


普通索引在索引命中第一条数据之后,还会在叶子节点继续往后面查询,直到查询到不是对应参数为止

唯一索引,命中第一条之后直接返回,不会再继续查询数据

但是在innoDB是按照页数据来查询,所以相邻的数据查询出来的消耗很小(不排除相邻两条数据刚好在不同页上的情况).所以上述区别微乎其微

**插入和更新效率**

唯一索引的特征:不允许索引字段重复

当数据在内存页中时:

+ 普通索引:找到位置,插入数据
+ 唯一索引:找到位置,判断是否重复,插入数据

当要插入的数据不在内存页中时:

+ 普通索引:更新记录到change buffer(没设计IO操作)
+ 唯一索引:从磁盘中获取到数据页,判断是否重复,插入这个值到磁盘中(涉及两次IO操作)

<font color="red">唯一索引不能使用change buffer</font>(因为需要校验是否会产生重复的数据,所以需要将磁盘中的数据查询到缓存中,这个操作就已经违背了change buffer的初衷(消耗更大),所以不会使用change buffer,而是查询出来直接更新)



## 13. 字符串字段创建索引（前缀索引）

正常针对字符串创建索引,只是针对整个字符串创建索引`alter table User add index idx_index1(tel)`

业务上经常会有类似这种场景

~~查找手机号前三个字符是移动号段“134,135,136,137, 138,139,147,150,151, 152,157,158,159,178,182,183,184,187,188,198，170，171，165”~~
~~所以我们会有类似这样的查询语句~~
~~select * from User where tel like '134%';~~

经常会使用手机号来查询用户信息
select * from User where tel ='12345678912';


所以针对索引字段是字符串,我们可以类似这种创建索引的方式`alter table User add index idx_index1(tel(3))`也就是取tel的前三个字符生成一个非聚集索引

但是使用前缀索引,会导致查询的时候比正常索引多执行一步操作
`获取到索引值之后需要比对是否是整体结果信息`

<font color="red">使用前缀索引优点:可以减少索引在内存中占用的空间,以前是索引整个tel,现在只用索引前三个字符即可.缺点是:进行一些查询操作的时候,多了查询的操作行为,增加了查询的消耗</font>

## 14. change buffer

mysql进行数据更新时,如果更新的数据刚好在内存中,那么就直接更新,如果没有在内存中.就会先将更新的操作缓存在change buffer中.

`change buffer`实际更新数据的情况有以下几个情况

+ 下次访问该数据页的时候,会同时将`change buffer`中的数据进行执行从而使查找的数据获得更新
+ 定时自动将数据更新到磁盘的数据页上:`merge`操作

`change buffer`的职能本质就是减少磁盘的IO操作

`change buffer`用的是`buffer pool`中的内存空间,可以使用设置数据库参数`innodb_change_buffer_max_size`来指定change buffer可以占用的buffer pool的百分比空间

**使用场景**:写多读少的业务场景 .而对于如果业务场景中所有的更新操作后面都带着查询,那么建议关掉`change buffer`

所以在生产环境中,mysql是有一个内存命中率的概念(命中率越高,说明使用的操作越高效)

## 15. B+Tree能存多少数据（为什么两千万是公认的需要分表的大小数据）

先弄懂几个地方：这里描述的是聚簇索引且索引三层

第一个、mysql的存储单元是页。叶子节点存储的是数据页，而非叶子节点的存储数据是索引字段值+指针

第二个、页的默认大小是16K，一个bigint类型的主键id是8字节，指针是6字节



开始计算：

根节点只有一个，这个无容置疑，那么第二层的非叶子节点是多少个呢，也就取决于根节点中能有多少个指针指向第二层。也就是16*1024/(8+6)=1170。也就是说每个页能有1170个数据。那么第二层也就有了1170个单元数据

每页可以指向1170个数据单元。第二层可以有1170个数据，那么第三层的数据单元就是1170*1170=1368900个数据单元。这么多个数据单元也就对应着可以有这么多个页。那么总共的数据大小就是1368900x16k。假设一条数据是1k（一般假设就这么大）。那么就是1368900x16条数据=21902400。也就是两千万多一点

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/Bplus树存储的数据量.drawio.png)

## 16. innodb的排序（order by）

一般建议在需要排序的字段上建立索引，因为B+索引本身就是有序的，这样可以很迅速的完成整个结果的排序。

如果是在没有索引的字段上进行排序。那么innodb有两个实现方案

方案一：两遍扫描算法，将要排序的字段和其对应的指针先取出来到内存中进行排序，完成之后再对排好序的结构取出来所有的记录数据

方案二：将所有需要的数据取出来在内存中进行排序，这样会比较吃内存空间，但是性能较高。如果出现大量的数据查询出来超过预设的内存空间，就会采用方案一

## 17. 查询优化器

一条sql语句的执行方式有很多种，比如可以使用联合索引，也可以使用普通索引，也可以进行全表扫描。但是究竟是怎么进行会在查询优化器中进行决定。比如创建了索引，却没有使用，为什么呢。举个例子select. *from  tb where customer_id>1;这个情况，明明有customer_id的索引，但是使用explain关键字却发现没有使用索引，而且`possible_key`中显示了idx_customer_id但是key中却是空。因为我虽然检测到你是可以用索引的，但是我用索引还是会检测出来所有的数据，然后我还需要进行回表。这个还不如我直接全表扫描来的快。所以就选择了全表扫描



总结：查询优化器就是判断走最近的一条查询记录的方式。所以就会出现即使设置了所有也命中了，但是仍然没有使用的情况

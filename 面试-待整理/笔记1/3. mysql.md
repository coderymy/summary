# Mysql的基本使用

## 表结构操作

```
1. 创建表
	create table <表名> (
		<字段名> <类型> [列级别约束] [默认值] [注释],
		<字段名> <类型> [列级别约束] [默认值] [注释],
		CONSTRAINT <约束名> FOREIGN KEY (A表的X字段名) REFERENCES B表(Y字段),
		[表级别约束]
	)[engine=引擎][default charset=字符集]
	CREATE TABLE `testdemo1`(
	`uid` INT PRIMARY KEY AUTO_INCREMENT,
	`username` VARCHAR(20) NOT NULL ,
	`password` VARCHAR(20) NOT NULL
	);
	
2. 主键约束
	1. Primary key
	2. 如果是联合主键，可以在表的创建结尾部分使用以下方式创建
		PRIMARY KEY(字段一，字段二)
3. 外键约束（reference）
	1. 在创建列的时候使用以下方式加上外键约束
		字段名 类型 REFERENCES B表(X字段)
	2. 在表创建尾部使用
		CONSTRAINT <约束名> FOREIGN KEY (A表的X字段名) REFERENCES B表(Y字段)
4. 复制表操作
	CREATE TABLE testdemo2 AS SELECT * FROM testdemo1;
5. 修改表
	alter table XXX XXXXXXXXXXX
6. 创建删除索引
	create index 索引名 on 表名(字段名)
	drop index 索引名;
```

> 约束条件

1. 主键约束
    PRIMARY KEY
2. 自动递增	
    auto_increment
3. 外键约束	
    REFERENCE，reference

## 2. 增删改查

### 2.1 增

```
insert into 表名(字段名1，字段名2，字段名3) values(值1，值2，值3);
```

### 2.2 删

```
delete from 表名 where 条件
```

### 2.3 改

```
update table set 列名1=值1，列名2=值2，where 条件
```

### 2.4 查

> #### 单表查询
>
> 1. 排序
>
> ```
> select * from 表名 order by 列名 DESC/ASC
> ```
>
> 2. IN
>
> ```
> select * from 表名 列名 in (值1，值2，值...)
> ```
>
> 3. 模糊查询 
>
> ```
> select * from 表名 列名 like 通配符
> 
> ```
>
> %. 表示匹配出现的任意次数的任意字符
>
> _. 匹配一个字符
>
> 4. 聚合函数，也就是在查询的信息中使用
>
> > 1. AUG()，平均值
> >
> > ```
> > select AUG(uid) from 表名
> > 
> > ```
> >
> > 2. COUNT()，某列数量
> > 3. MAX
> > 4. ()，某列最大值
> > 5. MIN()，某列最小值
> > 6. SUM()，某列的和
>
> 5. 分组查询
>
> > GROUP BY，表示分成什么组
>
> 6. HAVING子句
>
> 用于指定组所对应的条件，也就是可以是聚合函数。这就是和where的唯一区别，都是作为一种条件判断使用的
>
> 7. LIMIT子句
>
> 表示分页查询，指定

> #### 关联表查询
>
> 1. 基本使用
>
> ```
> select * from 表1,表2 where 主表.主键=从表.外键 and 其它过滤条件 
> ```
>
> 2. 内连接
>
> ```
> SELECT 主表.列1, ..., 从表.列1, ... FROM 主表 INNER JOIN 从表 ON 主表.主键 = 从表.外键 WHERE 过滤条件;
> 也就是在以前的基础上，在两个表中间加上了"inner join" 后面的链接条件加上"on"
> ```
>
> 3. 左外连接
>
> ```
> SELECT * FROM ... 
> LEFT JOIN ... ON ... = ...
> WHERE ...;
> 
> 和自连接的区别在于使用"left join"
> ```
>
> 4. 右外连接
>
> ```
> SELECT * FROM ... 
> RIGHT JOIN ... ON ... = ...
> WHERE ...;
> 
> 区别在于使用 "right join"
> 
> ```
>
> 5. 自连接
>
> 关键是使用别名

# 事务

InnoDB支持事务

<font color="red">一个事务以 `begin;` 开始，以 `COMMIT;` 或 `ROLLBACK;` 结束。</font>

> 四个基本特性

1. 原子性:要么全部执行，要么全部不执行；
2. 一致性:事务的执行使得数据库从一种正确状态转化为另一种正确状态；
3. 隔离性:在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；
4. 持久性:事务提交后，其结果永久保存在数据库中。

> 事务隔离级别

```
读未提交
读已提交---3
可重复读---23
串行化---123

READ_UNCOMMITTED（读未提交）: 一个事务还没提交,别人就能查询到我这个事务变更的数据
READ_COMMITTED（读已提交）: 其他流程只能读取到事务提交之后的数据
REPEATABLE_READ（可重复读）: 保证事务提交前和提交后的数据时一致的,也就是可以在提交前和提交后别的流程读取的数据都是一致的
SERIALIZABLE（串行）: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

解决问题，1. 脏读。2. 不可重复读。3. 幻读
```


# 存储过程

优点:封装性高,不易进行SQL注入,且执行效率较高

缺点:可移植性比较差

> 使用方法

```
create procedure 存储过程名()
BEGIN
xxxxxxx
END;

cell 存储过程名();
```

可以携带参数



# 数据库优化

​	
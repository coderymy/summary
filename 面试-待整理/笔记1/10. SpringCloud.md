# 了解各个组件

## 1. Eureka

注册中心

eureka包括eureka-server、eureka-client两个

client将本地服务的ip及监听的端口注册到server中

server有一个注册表,其中记录着所有的client的信息

client每隔一段时间会获取server的注册表信息将其缓存在本地

![图片](https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZMkG4ELsMmbSHDHwfFGic4CvHjEPqBW2iclGBwTzB4sD6VR2NU0xmMsoYicmWCXfPCQTn1LticB61OWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



## 2. feign

远程服务调用

动态代理的方式

![图片](https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZMkG4ELsMmbSHDHwfFGic4CT5y3EDh8DaEmDM4ibRNW0aTiaD8opMUFUCKX5yYxnGaqc7Kz7dicWm2kw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 3. ribbon

负载均衡

默认使用轮询的策略进行负载均衡

![图片](https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZMkG4ELsMmbSHDHwfFGic4CtD7kdmviciaXUubWd69erjZn8Hgw5ZZrDWYDBYCAiaBchGDxxwQj7Lic0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 4. hystrix

隔离、熔断和降级

![图片](https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZMkG4ELsMmbSHDHwfFGic4CZsj0neCTAwgfBVClSwTarrZ7gMRKAQlNviabrsOJ0DA9GcSmuZ2BTcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

逻辑中订单服务需要调用库存服务、仓储服务和积分服务.如果其中积分服务挂掉了.会导致订单服务中的线程阻塞,时间长了会影响订单服务访问其他服务.从而导致整体服务的宕机.所以这个时候就需要熔断机制.



## 5. zuul

网关

将所有的服务全部集合起来.由网关统一进行分发请求.

![图片](https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZMkG4ELsMmbSHDHwfFGic4CA7GmsCW8v9loCtGyHjPUa142lvp8aV4ViaFAsXDp6nGC9Z3ZryRKniaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

# 面试问题---eureka

1. **Eureka Server是如何保证轻松抗住这每秒数百次请求，每天千万级请求的呢？**
2. Eureka注册中心使用什么样的方式来储存各个服务注册时发送过来的机器地址和端口号？
3. 

## 1. eureka缓存与心跳机制

+ 缓存:eureka-client,每隔30s就会请求一次eureka-server拉去最近有变化的服务信息.
+ 心跳机制:eureka-client每隔30s请求一次eureka-server告诉server我还活着

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLbvlTGfketBG4ENjvReM6RGImhGtXgshicOL2QX1FafH9hTCDdmXc51CUbj6ftiaibLjDST0RtvOibkoA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 2. eureka注册表结构

基于纯内存维护的一个**registry**的**CocurrentHashMap**数据结构.

- 首先，这个ConcurrentHashMap的key就是服务名称，比如“inventory-service”，就是一个服务名称。

- value则代表了一个服务的多个服务实例。**Map<String, Lease<InstanceInfo**>>
  - key为服务的实例id
  - value是一个叫做**Lease**的类
  - 这个InstanceInfo就代表了**服务实例的具体信息**，比如机器的ip地址、hostname以及端口号。
  - 而这个Lease，里面则会维护每个服务**最近一次发送心跳的时间**

- 举例：比如“inventory-service”是可以有3个服务实例的，每个服务实例部署在一台机器上。



## 3. eureka-server的多级缓存机制

1. **ReadOnlyCacheMap**
2. **ReadWriteCacheMap**
3. **内存**

三十秒重置一次所有缓存数据,从内存中获取进行重新更新

- 在拉取注册表的时候：

- - 首先从**ReadOnlyCacheMap**里查缓存的注册表。

- - 若没有，就找**ReadWriteCacheMap**里缓存的注册表。

- - 如果还没有，就从**内存中获取实际的注册表数据。**

- 在注册表发生变更的时候：

- - 会在内存中更新变更的注册表数据，同时**过期掉ReadWriteCacheMap**。

- - 此过程不会影响ReadOnlyCacheMap提供人家查询注册表。

- - 一段时间内（默认30秒），各服务拉取注册表会直接读ReadOnlyCacheMap

- - 30秒过后，Eureka Server的后台线程发现ReadWriteCacheMap已经清空了，也会清空ReadOnlyCacheMap中的缓存

- - 下次有服务拉取注册表，又会从内存中获取最新的数据了，同时填充各个缓存。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLbvlTGfketBG4ENjvReM6RGZUKhPzd0ZNk4uiaZtZekErqU8yvo3qwHCzVeqjqpI5ZC6VvfO1balQg/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)


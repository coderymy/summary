# 问题

1、事务的隔离级别

> 读未提交：读到了别的事务没有提交的数据变更。
>
> 读已提交：事务的隔离性，只有别的事务提交了事务才会被获取到。但是当前事务中多次获取数据可能会出现不一致的问题
>
> 可重复读：基于MVCC的readView机制，实现在一次事务中，每次获取的数据都是一致的，保证重复读的数据是一致的。
>
> 串行化：所有事务执行都是顺序来的，不会出现并发问题

2、事务并发的问题，和解决方式

> 脏读：读到了别的事务未提交的数据，读已提交的隔离解决解决了该问题。
>
> 幻读：事务中，进行范围查找的时候。因为别的事务在该事务读取数据之后进行了数据的增删改，所以导致读到的数据和后续操作的数据不一致的问题。间隙锁解决幻读问题。
>
> 不可重复读：多次读取数据不一致，MVCC的机制解决了该问题

3、简述RedoLog、undoLog和binlog的区别

> 进行数据库操作，在持久化之前先写入redolog日志。保证持久化之前出现问题能进行数据的恢复。且避免频繁的访问磁盘空间带来时间的损耗
>
> 在事务执行期间，会产生对应执行语句的undolog，用于连接出错或其他错误从而进行事务回滚。

4、简述为什么索引使用B+树

> 首先树形结构的遍历速度很快，B树可以在节点上存储多个数据（用户联合索引）。B+树的所有根节点相互连接形成双向链表，便于进行范围查找。
>
> 根节点可以存储多个数据也方便聚簇索引的数据存储。

5、解释一下索引下推

>mysql5.6新增针对查询优化的
>
>在正常进行索引查询的时候,如果**还有其他查询字段,会先使用索引字段命中一部分数据,再使用其他字段进行比较.之后再进行回表操作**获取整张表的数据返回
>
>举例子
>
>```
>创建了name和age的联合索引
>select * from t1 where name=“李” and age =10
>mysql5.6之前:B+索引命中name->搜索->查找到多个结果->多个结果回表->回表结果判断age=10的返回
>mysql5.6之后:B+索引命中name->搜索->查找到多个结果->判断该次索引结果的age是否=10->符合条件的结果进行回表并返回
>```
>
>也就是说,mysql针对联合索引的查找字段,增加了在非聚簇索引获得值之后判断另一个参数是否满足条件这一步再进行回表操作
>

6、Mysql的主从复制原理

1、mysql进行增删改的时候会生成对应操作语句的binlog存储在binlog日志中

2、slave连接master之后，slave有一个IO线程定时的去访问master的binlog dump thread去获取binlog日志信息。

3、访问到日志之后存储在retry log中。然后salve会有一个线程专门从retry-log中取出来日志信息，持久化磁盘上

7、锁的分类

> 记录锁：使用**唯一性索引**进行等值查找。会将该条记录上锁`select * from user where id=1 for update`
>
> 间隙锁：可重复读级别下，使用**唯一性索引**进行**等值查询/返回查询**。会将该条记录和上一个间隙上锁`select * from user where id=5 for update`或`select * from user where id>2 and id<7`![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/picgo/20230227102434.png)
>
> 临键锁：记录锁+间隙锁。当前记录和该间隙都不允许修改。可重复读级别下，适用于**非唯一性索引**。
>
> + **在非唯一索引下如果SQL没有命中记录则就是间隙锁，命中了记录就是临键锁。**
>
> + **唯一索引且SQL命中了记录，那么加的就是普通记录锁，否则就是间隙锁。**
>

8、一条sql写入的流程

> 1、判断缓冲区是否有该数据。如果没有就将对应的数据的那一页缓存到内存中，并进行修改。（方便查询以及WAL机制）
>
> 2、写入redolog中。在事务提交之前将redolog写入磁盘
>
> 3、redolog的check到这条缓冲池的数据，再将该条数据的变更写入磁盘（缓冲区同步磁盘）

首先本文具有的标签性质是：锁、间隙锁、乐观锁、悲观锁、事务、隔离级别、MVCC、索引、B+树、explain关键字、主从复制等。

建议从上往下一点一点看，知识点之间都是相互关联的，顺序看有助于理解。

# 锁机制

## 按照锁范围分类

### **全局锁**

一般只有在进行库的逻辑备份的时候才会使用

锁对象是:整个数据库实例

<font color='red'>Flush tables with read lock (FTWRL)</font>-会让整个库处于只读状态

使用场景: 做全库逻辑备份



## 全库逻辑备份

**为什么要进行全局锁才能进行数据备份呢?**

就比如售卖,我一张表记录发货,一张表记录扣款.结果我在备份发货记录表.这个时候有人买东西了,只扣款了但是没有发货记录.这个显然是不行的


官方自带的逻辑备份工具是`mysqldump`。当`mysqldump`使用参数`–single-transaction`的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于`MVCC`的支持，这个过程中数据是 可以正常更新的。但是这个是基于**事务**的基础上的,针对`myisam`数据引擎就不可用,那么就有可能出现有的表不是基于innoDB的数据引擎

当然,如果全部都是innodb的数据引擎表,那么,还是使用默认的mysqldump增加参数`–single-transaction`来进行全局逻辑备份的好

## FTWRL和set global readonly=true的区别

1. readonly会在别的逻辑中参与使用(不同系统不一样)
2. ftwrl可以在客户端链接断开时,自动释放锁.防止造成死锁问题  



### **表级锁**

> 表锁

表级锁分为读锁和写锁。使用关键字`lock tables t1 read/write`加锁，使用`unlock tables`解锁（无需指定表）。或者在该线程的链接断开之后自动释放锁

锁定的表的操作其他线程就无法进行了

> MDL锁

MDL锁也是一个在表上操作的锁

在进行表字段的增删改查的时候，上读锁，在事务结束的时候释放

在进行表结构变更/索引变更的时候，上写锁，在事务结束的时候释放

*只要有写锁的存在，其他的线程的操作都是会阻塞的*。也就是说在修改表结构，创建表索引的时候，会影响其他线程的一切操作。

### **行级锁**

[行级锁区分](https://mp.weixin.qq.com/s/xINelH82bjxYGFh6NdrHFQ)

行锁是由各自的引擎实现的，例如InnoDB有行锁，MyIsam没有行锁。

在进行数据变更的时候上锁，在事务结束的时候自动释放锁

多个线程对同一行进行修改就会导致需要等待一个线程的锁释放(事务结束)才能进行修改

> **死锁**
>
> 行锁很容易造成死锁
>
> 例如
>
> 1. 线程1修改了id=1的数据，上锁
> 2. 线程2修改了id=2的数据，上锁
> 3. 线程1想要修改id=2的数据，但是在锁中，所以等待线程2的释放
> 4. 此时线程2又想要对id=1的数据修改，所以等待线程1的释放
> 5. 此时就造成了死锁（你俩搁着闹呢）
>
> 解决方案：
>
> 1. 等待其中一个线程的链接请求超时时间过了，就会自动断开链接从而自动释放锁
>
> 2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑（默认开启）
>
>    问题：就是每当一条数据被锁住的时候，就要检测下别的依赖这条数据的线程是否存在被锁住的情况。对性能有很高的损耗
>
>    如果对业务清晰不会出现类似上述的死锁情况，可以将参数改为off从而提升性能

哪些语句会加行锁：

1、DML语句，进行update、delete、insert的时候

2、select的时候加上了for update或lock in sharemode

3、使用的是串行化的隔离级别

#### 记录锁

锁住某一行记录

#### 间隙锁

锁住一段左开右开的区间

一个很特殊的存在，是为了解决幻读问题（即，我以为我修改了全部的十条数据，其实在我修改期间又新增了第十一条数据）

例如：update t1 set record="蛋炒饭" where num<10;

虽然num<10的只有三条数据（num=2,num=5,num=7），但是在这个期间如果新增了数据就会造成幻读的情况。所以这个时候上锁的其实是

+ num=2的记录行锁
+ num=5的记录行锁
+ num=7的记录行锁
+ (-无穷大,2)(2,5)(5,7)(7,10)这四个范围的间隙锁

#### 临键锁

锁住一段左开右闭的区间

记录锁+间隙锁。当前记录和该间隙都不允许修改。可重复读级别下，适用于**非唯一性索引**。

+ **在非唯一索引下如果SQL没有命中记录则就是间隙锁，命中了记录就是临键锁。**

+ **唯一索引且SQL命中了记录，那么加的就是普通记录锁，否则就是间隙锁。**

#### 三种锁总结

锁的基本单位是临键锁，只是出现不满足临键锁的情况了才降级

唯一索引等值查询（临键锁需要是非唯一索引）：

+ 查找到记录，是记录锁
+ 未查到记录，是间隙锁

唯一索引范围查询

+ 找到记录，就是记录锁
+ 未找到记录，范围就是对应区间的两边的两个间隙锁（且因为未找到数据，所以两边都是开区间）

```sql
select * from user
where id >= 20 and id < 22
for update;
最后锁定的是id=20（因为id=20存在这个记录）。
和（22，25）因为要找到数据<22所以25不记录在内。
```

非唯一索引等值查询：

+ 记录存在，记录左区间临键锁、右区间间隙锁
+ 记录不存在，左右区间都加临键锁，但是因为不存在所以退化成间隙锁。所以**左右区间都是间隙锁**

非唯一索引范围查询：

+ 左右区间加临键锁。查询的具体记录不存在就在锁中去除该节点

引用：[行级锁区分](https://mp.weixin.qq.com/s/xINelH82bjxYGFh6NdrHFQ)

## 死锁

很多情况都回引起死锁,大部分都是针对数据库操作有问题才会导致.比如

```
线程A和线程B都针对id=1和id=2进行修改并开启事务

线程A先修改了id=1导致id=1被线程A上锁

线程B修改了id=2导致id=2被县城B上锁

此时线程A要等待id=2释放锁后执行对id=2的操作
而线程B要等待id=1释放锁后怼id=1的操作

从而达到了一个循环死锁的情况
```

处理这种问题有两个策略:

1. 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout(默认50s)来设置。这个不能设置太短,如果不是死锁呢?
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事 务得以继续执行。将参数innodb_deadlock_detect设置为on(默认就是on)，表示开启这个逻辑。


## 记录锁

属于行锁的一种情况

针对的是事务在加锁后锁住的某一条记录信息

触发情况:查询条件精准命中且命中的条件字段是唯一的
例如:`update t1 set name="张三" where id=12138`

作用:记录在被当前事务管理时,加上锁之后不会被其他事务获取产生“重复读”和“数据脏读”的问题

# 乐观锁和悲观锁

| 概念     | 乐观锁                                                       | 悲观锁                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 概念     | 假定不会发生并发冲突<br>只在提交时判断下是否有数据问题       | 假定会发生并发冲突<br>从而上锁                               |
| 实现层面 | 业务代码层面,自己实现<br>(需要结合具体业务逻辑)              | mysql数据库自身实现                                          |
| 并发情况 | 并发大                                                       | 并发小                                                       |
| 实现方式 | 在数据库中增加版本号字段,<br>提交时判断操作前的版本号和当前版本号是否一致 | 共享锁:select lock xxxxxx<br>排它锁:select xxxx for update   |
| 其他     |                                                              | mysql中的synchronized其实就是排它锁<br>共享锁:运行其他线程`查`不允许`增删改`<br>排它锁:`增删改都不允许` |





## 按照锁本质分类

|          | 乐观锁                                                       | 悲观锁                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原理     | 认定不会出现数据冲突，<br>所以只是维护一个版本号，<br>在业务处理结束的时候验证下版本号是否正确（即该业务处理期间有没有数据变更） | 认定业务处理期间一定会发生数数据变更冲突<br/>在业务处理之前先获取到锁<br/>要求别的线程必须等待锁的释放才能继续该逻辑 |
| 实现方式 | 业务实现<br>1. 获取该条数据的版本号<br>2. 业务操作<br>3. 业务处理完之后判断该条数据的版本号是否变更，如果变更就进行回滚等操作 | Mysql实现，在进行select操作的时候加上`for update`关键字，在当前事务结束之后自动释放锁。<br>别的线程在事务结束之前进行该条记录的变更都会进入阻塞状态，直到锁的释放 |



# 事务

## 四大特性

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/0s9ncl.jpg)

|              | 原子性**A**tomicity                                          | 一致性**C**onsistency                                        | 隔离性**I**solation                       | 持久性**D**urability                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------- | ------------------------------------------------------------ |
| 解释         | 事务是最小的单位,不允许进行分割,<br>                         | 事务执行之前和执行完成之后这个<br>业务数据的状态是一致的（不会出现中间状态的数据） | 多个事务执行期间对数据的修改不会相互影响  | 事务执行完成之后,对数据的修改会保存在数据库中,不会再有回滚的操作出现 |
| 详细解释     | 即**事务所执行的操作要么都完成要么都失败**                   | 这个一致性其实很多概念解释的都很模糊,比如<br/> 1. ~~事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。~~<br/> 2. ~~一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。~~<br/>其实这些说法也对,但是没有说到点子上去<br/>就拿上面转账来说,事务的一致性**其实就是多个事务看这个总钱数,无论是这个事务之前前还是执行后,都是一样的.也就是别的事务不会看到这个事务执行期间的中间状态(中间状态从A扣钱和给B加钱肯定是有个顺序的,这个时候钱的总数肯定的少了或者多了的)**<br/>那么就有的人会问了,那么这个概念不是和原子性一致了嘛<br/>原子性关注于状态,要么都成功要么都失败<br/>而一致性关注于数据,保证事务执行期间的这个数据不会超脱于业务之上 | 多个事务执行期间,对同一条数据不会产生影响 |                                                              |
| 实现方式     | 使用undo log实现                                             | 一般由代码层面来保证                                         | 通过加锁和MVCC去实现的                    | 使用的redo log实现的                                         |
| 实现方式详解 | 1. 在操作任何数据之前,都先将数据备份到另一个地方(这个地方称之为undo log)<br/>2. 然后就行数据修改<br/>3. 如果出现异常或者执行了rollback操作,系统就使用undo log中的数据将数据恢复到事物执行之前的状态 |                                                              |                                           | 1. 操作任何数据的时候,都将操作之后的数据进行备份到一个地方(这个地方就叫做redo log)<br/>2. 事务提交之前将redo log持久化<br/>3. 如果 系统出现崩溃则可以直接使用redo log恢复数据 |

## 事务并发的问题

+ **脏读（Dirty read）:** (读取了后来回滚的操作)事务A读取了事务B未提交的数据修改,事务B又回滚了(读了不该读的数据)
+ **幻读（Phantom read）:** (我以为我读取了全部)事务A读取了全部学生进行操作,结果事务B又加了学生(幻想自己读了所有)
+ **不可重复读（Unrepeatableread）:**(我读取的数据被修改了)事务A读取的数据被事务B修改并提交了(同一个事务读的两次结果不一样了)与幻读的区别在与幻读针对新增和删除.不可重复度在于修改

理解起来很好理解,就是容易记混,哈哈哈

## 隔离级别

|                                                    | 读未提交                                 | 读已提交                                                     | 可重复读                                                     | 串行化               |
| -------------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- |
| 英文及简写                                         | Read UnCommited                          | Read Commited（RC）                                          | Repeatable    Read（RR）                                     | Serializable         |
| 概念                                               | 别的事务可以读到这个事物未提交的数据变更 | 该事务的数据变更只有在提交之后才能被别的事务读取到（**但是在一个事务中两次获取的数据可能是一样的**） | 在一个事务的过程中每次获取的数据都是一样的（即使有别的事务修改了数据并提交了） | 所有事务都是依次执行 |
| 避免的问题<br>（重复读、脏读、幻读）               | null                                     | 脏读（MVCC解决可重复读问题）                                 | 脏读和重复读                                                 | 所有                 |
| 数据库默认                                         |                                          | oracle默认                                                   | mysql默认                                                    |                      |
| 备注                                               |                                          | MVCC解决可重复读问题                                         | 为了解决**可重复读**的问题，Mysql使用了MVCC的方式。为了解决**幻读**的问题，Mysql使用了间隙锁。在该隔离级别上都有体现 |                      |
| 生成readView的时机（MVCC作用在RR和RC上不同的原因） |                                          | 事务中每次select都会生成一个readView                         | 每个事务创建一个readView                                     |                      |

在启动参数中设置`transaction_isolation`即可配置事务隔离级别,查看当前隔离级别` show variables like 'transaction_isolation'`默认隔离级别是“可重复读”

## MVCC

> 大体总结一句话描述什么是MVCC：
>
> 为了解决事务的问题“不可重复读”，MVCC相当于有一个版本号的概念，在事务开启的时候有一个快照，后续每次进行查找的时候，都会基于“版本号”进行回退查找历史更改记录。直到获取到<=这个版本号的数据。这样在该事务中获取的数据都会是一样的，不会因为别的线程修改而导致前后两次获取/修改的数据不一致

### 为什么要使用MVCC？（Why）

Multi-Version Concurrency Control，多版本并发控制。

由上面MDL锁可知

| 未使用MVCC | 读操作 | 写操作 |
| ---------- | ------ | ------ |
| 读操作     | 不阻塞 | 阻塞   |
| 写操作     | 阻塞   | 阻塞   |

只要涉及写操作的都会出现阻塞的情况。MVCC的机制就可以将上述MDL锁变成如下

| 使用MVCC | 读操作 | 写操作 |
| -------- | ------ | ------ |
| 读操作   | 不阻塞 | 不阻塞 |
| 写操作   | 不阻塞 | 阻塞   |

也就是只有多个线程进行写操作的时候才会出现阻塞的情况。由此大大提升了数据的操作性能



### 什么是MVCC？（What）

> 首先理解几个概念
>
> + **当前读**：悲观锁状态下，有些业务要求的就是最新的数据。例如像select lock in share mode(`共享锁`), select for update ; update, insert ,delete(`排他锁`)这些操作都是一种当前读。他们操作的都得是最新的数据。
>
> + **快照读**：在非串行化的隔离级别下`不加锁`的select操作就是快照读。（串行化时快照读退化成当前读，毕竟执行严格按照顺序来了，也就没有之前数据一说了）这也就是为什么能够解决`可重复读`的问题的根由。

综上所述：为了解决提升数据库操作性能->解决有写锁在的情况下的读操作阻塞问题->快照读解决`可重复读`的问题->所以就衍生出了MVCC这种机制

> 这里有几个考察点
>
> 1、快照读只有在隔离级别是RR和RC的时候才是快照读，在串行化的情况下会变成当前读。在读未提交的级别下没有锁的概念，无所谓什么快照读了
>
> 2、当前读是指增删改和加锁的读。都是针对悲观锁的行锁。快照读一般针对我们业务用的最频繁的不加锁的select操作

### MVCC的实现原理

> 再有几个概念理解下
>
> + 三个隐式字段
>   + **`DB_TRX_ID`**
>     6byte，最近修改(`修改/插入`)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
>   + **`DB_ROLL_PTR`**
>     7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
>   + `DB_ROW_ID`
>     6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以`DB_ROW_ID`产生一个聚簇索引
>
> + undolog（区别于redolog）
>
>   会在每条DML语句都会生成一条相反的DML语句（比如delete就会生成一条insert语句）这个相反的语句会用在进行数据回滚等操作。undolog中记录的就是这种语句以及其一些基本信息（事务id、版本号等）
>
>   + Insert undo log ：涉及insert操作，回滚使用
>   + update undo log：涉及update、delete操作，回滚和快照读使用
>
> + Read View（读视图）：事务在执行快照读的那一刻生成的数据库系统的一个快照
>
>   作用：是为了能确定在版本链（undolog组成的链表）要选择的是哪个记录
>
>   其中记录的数据：
>
>   | 参数           | 描述                                           | 举例 |
>   | -------------- | ---------------------------------------------- | ---- |
>   | m_ids          | 生成该视图时所有活跃的<br>（未commit的）事务ld | 1、3 |
>   | min_trx_id     | m_ids中最小的事务id                            | 1    |
>   | max_trx_id     | 生成该视图时，<br>事务id分配器下个生成的id     | 4    |
>   | creator_trx_id | 生成该视图的事务id                             | 2    |

**哪些版本可以被访问到（commit的事务可以访问）**

   1. 如果版本链中trx_id有=creator_trx_id，可以。就使用这条undolog（我本身进行的操作）
   2. trx_id<min_trx_id，可以。说明trx_id肯定是提交了的id了
   3. trx_id>max_trx_id，不可以，相当于该trx_id是创建视图之后的id，不能读取
   4. min_trx_id<=trx_id<=max_trx_id且m_ids.isNotContains(trx_id)，可以，因为在m_ids中的事务是活跃的也就是没有commit的事务。

**MVCC实现步骤**

第一步：根据进行的DML操作生成undolog，使用其中的`DB_ROLL_PTR`来组成版本链

第二步：当启动一个事务之后，进行了快照读，则根据上述`哪些版本可以被访问到`的条件进行生成对应的`readView`

第三步：在进行CRUD的时候，根据readView可以判断出版本链中的哪条数据可以被当前事务读取到从而确定被CRUD的数据最终的状态是什么样的

   ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/u1zLsy.png)

### MVCC在RR和RC中的区别

**生成ReadView的时机不同**

RC是在一个事务中每次进行select操作的时候就生成一个readView。（如果两个select操作之间有提交的事务，那么第二次select的版本链就不一样了）

RR是在事务创建的时候针对这个事务生成一个readView（所以每次进行select的时候都是同一个）

# 索引

## B+树

![Mysql使用B+树的演变来由](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/UVqJiC.jpg)

二叉树、平衡二叉树、AVL树、哈夫曼树、红黑树、B-树、B+树

讲索引必讲B+树，讲B+树就必得将整个树形结构回顾一遍

|      | 二叉树                   | 平衡二叉树（AVL树）      | 满二叉树<br>与完全二叉树                                     | 红黑树 | B-树（B树） | B+树 |哈夫曼树|
| ---- | ------------------------ | --------------------- | ------------------------------------------------------------ | ------ | ---- | ---- |---|
| 特点： | 每个节点最多有两个子节点 | 每个子树左右子树高度差不超过1 | 满：每层都是满的<br>完全：将满的从右到左<br>、从下到上删除一部分节点 | 1. 叶子节点不存储数据<br>2. 根节点黑色，叶子节点黑色<br/>3. 从一个节点到该节点的所有子孙节点都包含同样的黑节点数 | 一个节点可以有多个元素 | 在B-树的基础上所有叶子节点都是使用指针相互连接的 | 两个孩子节点的值之和是根节点的值 |
|  |  |  | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/BWlmNA.png) | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/hIsQyV.png) | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/B树.png) | ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/Bplus树.png) |  |

B树：相对于其他树结构，B树每个节点可以存储多个元素

B+树：相对于B树，B+树叶子节点之间使用指针相互关联

## 页

我们使用的操作系统从磁盘中获取数据是按照页（4kb）获取的，mysql从磁盘中获取的页是16kb

页的构成：

1、**用户数据区域**：也就是真实进行数据存储的数据区，使用链表结构存储

2、**页目录**：类似于书本的目录系统，简化查询操作提高查询销量

3、**页头**：其中有前后指针，也就是导致我们可以有双向的指针来获取前后的范围数据页

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/RYVUSZ.jpg)

总结:

<font color='red'>B+树的非叶子结点就是所有页数据构成的一个树结构</font>

<font color='red'>B+树的叶子结点,存储的就是各个页的数据信息,页与页之间使用双向链表相互连接</font>

所以这里的查询操作就变成了

1. 首先去页构成的目录中使用二分查找到需要获取的页
2. 从磁盘中取出页
3. 在页目录中找到数据区域分配的组信息
4. 在数据区域找到对应的数据



## 索引结构

下面就相当于是一个<font color='red'>主键索引(聚簇索引)</font>

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/5JsmaE.jpg)

总结:

<font color='red'>B+树的非叶子结点就是所有页数据构成的一个树结构</font>

<font color='red'>B+树的叶子结点,存储的就是各个页的数据信息,页与页之间使用双向链表相互连接</font>

所以这里的查询操作就变成了

1. 首先去页构成的目录中使用二分查找到需要获取的页
2. 从磁盘中取出页
3. 在页目录中找到数据区域分配的组信息
4. 在数据区域找到对应的数据

# mysql索引及索引失效的各个情况

**索引在存储中的目的**:就是作为一个页构成的目录.提升获取对应页的速度(因为页存在磁盘中,所以如果全表扫描一个一个便利,就需要进行很多次的IO操作.而使用索引命中了对应的页就只需要进行一次IO操作即可)

主键索引:

1. 使用B+树维护的一个树形结构,叶子结点是对应的页.非叶子结点是页构成的一个查询目录
2. 页中包含页目录和数据区,页目录中的数据将数据区分成不同的区,方便查找



>  **最左前缀原则**

![]()

原理:构建的联合索引,虽然有多个字段,但是最先比较的都是最左边的字段,如果没有最左边的字段,那么就没办法在B+树上进行判断走向

即:其实创建联合索引的时候,实际上是从左向后创建索引

举例:index(a,b,c),其实会创建类似index(a),index(a,b),index(a,b,c)的索引信息.而针对只有b和c的数据查询是命中不了索引的



> **聚簇索引和非聚簇索引**

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/A6ycRk.jpg)

使用非聚簇索引的目的:

1. 减少空间的使用,因为如果创建一个索引就备份所有页的数据是很消耗空间的
2. 进行update操作就需要对所有索引的数据进行修改

> **索引失效**

规则:

1. 联合索引最佳左前缀原则
2. 针对索引的任何操作都会失效(函数、计算等)`select  * from t where left(name,4)='July'
3. 多次回表会使索引失效(覆盖索引:查询的字段是索引结果信息,不需要回表就可以获取)
4. 索引上使用`!=`、`<>`、`is null`、`is not null`会失效
5. 使用like且以通配符开头会失效 `select * from t where name like '%鱼'`会失效,但是`select * from t where name like '香%'`不一定会失效
6. 索引字段是字符串,但是查询时候字符串未加‘’会失效
7. 索引字段使用`or`会失效,建议使用`union`修改

> **字符串索引**

会根据字符串的**字符规则**进行排序,可能针对不同的国家的字符顺序不一样



![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/ahaTj9.jpg)

# 哈希索引

也就是使用hash算法,使用链表的方式解决hash冲突,来定位到需要查询的结果信息

支持hash的引擎有MEMORY(这里需要谷歌)，其他的引擎都通过各自的方式去支持hash方法。如InnoDB有一套自适应hash算法，内部实现还是采用了BT的方式，可以理解为BT索引的索引

设置hash索引是否生效:`set global innodb_adaptive_hash_index=off/on`

hash索引虽然使用hash算法的查询销量较高,但是有很多弊端,所以一般不建议随意使用

+ 不支持范围查找
+ 不支持查询排序
+ 不支持模糊查找

## Explain

目的就是为了检查查询语句的索引命中情况，从而来进行索引优化或者查询条件的优化

下面对几个重要的参数进行解释

1、**select_type**，select子句的查询类型，主要用来在进行子查询或者合并查询的时候区分进行的哪条查询

+ **Simple**：普通情况，未使用子查询或者union查询（合并查询结果数据使用）

+ **primary**：子查询的最外层查询/union最前面的那个查询

+ **UNION**：合并的后面那个子句

  ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/Wi0d84.png)

+ dependent union：第二个union的查询结果依赖于第一个查询结果

+ union result：合并的操作

+ subquery：子查询中的第一个select，结果不依赖外部

+ dependent subquery：子查询中的第一个select，结果依赖外部

+ DERIVED：

+ UNCACHEABLE SUBQUERY

2、<font color="red">**type**</font>

+ **ALL**：该操作进行了全表遍历

  ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/h1dbYr.png)

  出现的情况

  + 查询的操作就是要查询出来全表的所有数据，比如id>0
  + 查询的操作字段没有索引，比如operator='小红'
  + 查询的操作字段有索引，但是没有命中，比如first_class=1（不符合最左前缀原则）

  **这种ALL的操作很耗时，需要优化**

+ **index**：遍历了索引树，但是没有回表。效率要比ALL高很多，因为回表的消耗会很大

  ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/dXYRZf.png)

+ **range**：基于索引的范围查找，也就是在索引上进行了范围查找

  `<`，`>`,`between`,`in`,`or`等操作

+ **ref**：命中索引查找，但是查找值不唯一。

+ **ref_eq**：命中了唯一索引/主键索引，查找值唯一

+ **const**：命中主键索引

3、**possible_keys**，表示命中的索引（有可能会命中多个，比如idx_orderNo，idx_orderNo_num）等

4、**Key**，表示真正使用的那个索引，必然在possible_keys其中一个

5、**key_len**，一般表示索引列的类型长度

6、<font color="red">**rows**</font>，表示查询到目标值需要遍历的数据量

7、ref，表示哪些列、常量被来用来查询索引上的值

8、filtered，TODO查了很多情况说这个是目标行数占检索总行数的百分比。但是好像不太多，目前还没理解为什么。

9、**Extra**，这个值还没理解，经过实战发现网上说的好多都是错的，所以还没总结，后续补充

# redolog、undolog和binlog

## redolog(保证事物提交的持久性)

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/N8wj7n.jpg)
默认有四个文件进行循环存储.

也就是在进行数据库操作的时候,并不是实时就将数据更新到磁盘中,而是一个异步的流程.如果进行update操作,分为以下几个步骤

WAL机制(write ahead logging)

1. 数据库进行sql校验是否能够执行
2. 进行资源锁定(事务不一定存在)
3. write pos写入redolog并于client交互返回成功
4. checkpoint顺序执行执行到这条语句进行磁盘的数据update操作
5. 并擦除这条redolog操作行为




## undolog(保证事物的回滚和MVCC中的版本概念)


记录了一条增删改操作的相反数据变更,也就是变更前的数据记录信息.方便在回滚时候进行数据变更回去

也记录MVCC中的一个版本号.当用户读取一行记录时,若该记录已经被其他事务占用,当前事务可以通过undo读取之前的行版本信息,以此实现非锁定读取。


## binlog

记录实际最终对数据的操作的语句,记录的是二进制信息


## redolog和binlog

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
2. binlog是追加写,redolog是循环写

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/m17UMw.jpg)

# 主从复制

默认使用<font color="red">异步</font>的方式进行主从复制，这样从节点不需要一直访问主服务器进行更新

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/1. 主从复制原理.PNG)

涉及三个线程

1. 主服务器的**binary log dump 线程**
2. 从服务器的**I/O线程**
3. 从服务器的**SQL线程**

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/2. 主从复制原理 .PNG)

<font color="red">复制过程：</font>

1. 从节点上的IO进程连接主节点，并请求获取从指定的日志的指定位置之后的日志内容
2. 主节点获取请求后，将对应的日志内容返回给从节点，还包括本次返回的信息的bin-log file 的以及bin-log position
3. 从节点接收数据后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，
4. Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。

<font color="red">主服务器的日志被从服务器的`I/O线程`读取，写到从服务器的日志中，再被从服务器的`SQL 线程`操作，从而写到服务器中</font>



# 常见Q&A

## 事务

## 索引

### 1. 为什么使用B+树作为索引的数据结构而不使用hash索引

> 都知道mysql索引使用的数据结构是B+树,那么就需要先了解B+树的相关原理和使用方式
>
> **平衡二叉树**
>
> 平衡二叉树与普通的二叉树的区别在于:二叉树中任意一个节点的左右子树的高度相差不能大于 1就是平衡二叉树
>
> ![Mysql使用B+树的演变来由](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/UVqJiC.jpg)
> 二叉树(树结构查询快)->平衡二叉树(解决二叉树出现极端情况的问题)->B树(多节点,高度远小于红黑树等)->B+树(外接链表,增加范围查找的功能.非叶子结点只保存索引不保存数据节省空间)
>
> **选择B+树的原因**
>
> 1、B+树每个节点可以存储多个数据，用来实现mysql的联合索引
>
> 2、Mysql使用的B+树叶子节点之间使用双向链表，用来实现mysql的范围查找
>
> 3、类似“目录”功能,树只保存索引,下挂的链表保存数据
>
> **不选择hash的原因**
>
> 底层使用的是hash表结构，也就是key-value的结构。这样就局限于查找方式只能使用等于进行查找。否则就需要进行全表扫描
>
> 1、不支持范围查找
>
> 2、不支持查询排序
>
> 3、不支持模糊查找
>
> 4、哈希索引会出现hash冲突，这样的查询效率会变的很低从而无法实现联合索引

### 2. 为什么使用聚簇索引和非聚簇索引

1. 减少空间的使用,因为如果创建一个索引就备份所有页的数据是很消耗空间的
2. 防止进行update操作就需要对所有索引的数据进行修改

## 3. mysql索引及索引失效的各个情况

**索引在存储中的目的**:就是作为一个页构成的目录.提升获取对应页的速度(因为页存在磁盘中,所以如果全表扫描一个一个便利,就需要进行很多次的IO操作.而使用索引命中了对应的页就只需要进行一次IO操作即可)

主键索引:

1. 使用B+树维护的一个树形结构,叶子结点是对应的页.非叶子结点是页构成的一个查询目录
2. 页中包含页目录和数据区,页目录中的数据将数据区分成不同的区,方便查找



>  **最左前缀原则**

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/EFoU2r.jpg)

原理:构建的联合索引,虽然有多个字段,但是最先比较的都是最左边的字段,如果没有最左边的字段,那么就没办法在B+树上进行判断走向

即:其实创建联合索引的时候,实际上是从左向后创建索引

举例:index(a,b,c),其实会创建类似index(a),index(a,b),index(a,b,c)的索引信息.而针对只有b和c的数据查询是命中不了索引的

> **索引失效**

规则:

1. 联合索引最佳左前缀原则
2. 针对索引的任何操作都会失效(函数、计算等)`select  * from t where left(name,4)='July'
3. 多次回表会使索引失效(覆盖索引:查询的字段是索引结果信息,不需要回表就可以获取)
4. 索引上使用`!=`、`<>`、`is null`、`is not null`会失效
5. 使用like且以通配符开头会失效 `select * from t where name like '%鱼'`会失效,但是`select * from t where name like '香%'`不一定会失效
6. 索引字段是字符串,但是查询时候字符串未加‘’会失效
7. 索引字段使用`or`会失效,建议使用`union`修改

> **字符串索引**

会根据字符串的**字符规则**进行排序,可能针对不同的国家的字符顺序不一样



![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/ahaTj9.jpg)

## 4. 简单介绍下对mysql索引的理解

mysql索引包括主键索引、唯一索引、普通索引、联合索引及MyISAM引擎自带的全文索引等

InnoDB引擎默认索引的实现数据结构是B+树,为了更快命中所查询数据在磁盘中存储的是哪个页,从而减少查询时间及减少磁盘IO的次数

创建索引使用`create [索引属性] index 索引名 on 表名(索引字段(索引条件等))`

索引是一种以空间换时间的一种系统优化方式

默认创建表后会生成一个主键索引,如果不指定主键索引会自动获取表中的一个唯一索引生成主键索引,如果没有会自动虚拟出一列`rowId`作为主键索引

## 5. 为什么innoDB要使用B+树作为索引的数据结构

B+树的数据结构有如下几个特点便于mysql的搜索

+ 每个节点可以有多个值(联合索引)
+ 叶子结点包含全部的索引数据(结果查询)
+ 叶子结点使用双向指针进行指向(便于范围查找)

索引演化也是按照需求来的,具体可以看上面的索引演化过程



## 6. 为什么主键建议使用自增的,而不是uuid

+ 插入数据的时候主键会维护一个聚集索引,索引使用的是B+树实现,B+树在增加数据的时候,从中间插入的效率要远小于从末尾插入一个数据
+ 在页中存储的数据,如果从中间插入数据,会导致相应后续的数据需要”换页“的问题



## 7. 面试问你联合索引什么情况下会命中索引

+ 最左前缀原则

+ mysql也有自己校验的优化器,即如果判定走索引的消耗比全表扫描的消耗还大,就不会进行索引数据

  类似全表扫描只需要一次查询出来,但是如果使用非聚簇索引还需要进行非常多次的回表操作,这个时候就不会进行索引

## 8. 常见的面试索引命中问题

表(a,b,c,d,e),index(b,c,d),primary(a)

| 查询语句                        | 是否使用索引 | 原因                                                         |
| ------------------------------- | ------------ | ------------------------------------------------------------ |
| select * from t where b>1       | 否           | 因为需要进行多次回表操作                                     |
| select a,b,c,d from t where b>1 | 是           | 查询条件在非聚簇索引上就可以获得,不需要回表                  |
| select b from t                 | 是           | 使用索引,但是是索引扫描.<br>因为索引存储数据量要小,所以分配的页少,<br>进行数据库的IO操作次数更少 |
| select * from t order by b,c,d  | 都可         | 不使用索引(数据量少):全表扫描,需要进行重新排序<br>数据量少时直接在内存中排序速度快,如果速度量过多内存不足<br>以构成排序操作就需要进行一些规则性的操作(比如一次比较一部分))<br>使用索引:不需要排序直接使用索引排序,需要大量的回表操作 |

## 9. 什么叫做**覆盖索引**

注意,并不是一种索引类型,而是一种索引操作

即查询结果信息可以直接在索引树结束获得,不需要再进行回表来获得数据.这种查询操作就叫做覆盖索引



## 10. <font color="red">说下**索引下推**</font>

mysql5.6新增针对查询优化的

在正常进行索引查询的时候,如果还有其他查询字段,会先使用索引字段命中一部分数据,再使用其他字段进行比较.之后再进行回表操作获取整张表的数据返回

举例子

```
创建了name和age的联合索引
select * from t1 where name=“李” and age =10
mysql5.6之前:B+索引命中name->搜索->查找到多个结果->多个结果回表->回表结果判断age=10的返回
mysql5.6之后:B+索引命中name->搜索->查找到多个结果->判断该次索引结果的age是否=10->符合条件的结果进行回表并返回
```

也就是说,mysql针对联合索引的查找字段,增加了在非聚簇索引获得值之后判断另一个参数是否满足条件这一步再进行回表操作



## 11. 简单介绍下explain的使用

查看上文



## 12. 普通索引和唯一索引

区别: 唯一索引指定的字段保证唯一性

性能分析:

**查询效率**


普通索引在索引命中第一条数据之后,还会在叶子节点继续往后面查询,直到查询到不是对应参数为止

唯一索引,命中第一条之后直接返回,不会再继续查询数据

但是在innoDB是按照页数据来查询,所以相邻的数据查询出来的消耗很小(不排除相邻两条数据刚好在不同页上的情况).所以上述区别微乎其微

**插入和更新效率**

唯一索引的特征:不允许索引字段重复

当数据在内存页中时:

+ 普通索引:找到位置,插入数据
+ 唯一索引:找到位置,判断是否重复,插入数据

当要插入的数据不在内存页中时:

+ 普通索引:更新记录到change buffer(没设计IO操作)
+ 唯一索引:从磁盘中获取到数据页,判断是否重复,插入这个值到磁盘中(涉及两次IO操作)

<font color="red">唯一索引不能使用change buffer</font>(因为需要校验是否会产生重复的数据,所以需要将磁盘中的数据查询到缓存中,这个操作就已经违背了change buffer的初衷(消耗更大),所以不会使用change buffer,而是查询出来直接更新)



## 13. 字符串字段创建索引（前缀索引）

正常针对字符串创建索引,只是针对整个字符串创建索引`alter table User add index idx_index1(tel)`

业务上经常会有类似这种场景

~~查找手机号前三个字符是移动号段“134,135,136,137, 138,139,147,150,151, 152,157,158,159,178,182,183,184,187,188,198，170，171，165”~~
~~所以我们会有类似这样的查询语句~~
~~select * from User where tel like '134%';~~

经常会使用手机号来查询用户信息
select * from User where tel ='12345678912';


所以针对索引字段是字符串,我们可以类似这种创建索引的方式`alter table User add index idx_index1(tel(3))`也就是取tel的前三个字符生成一个非聚集索引

但是使用前缀索引,会导致查询的时候比正常索引多执行一步操作
`获取到索引值之后需要比对是否是整体结果信息`

<font color="red">使用前缀索引优点:可以减少索引在内存中占用的空间,以前是索引整个tel,现在只用索引前三个字符即可.缺点是:进行一些查询操作的时候,多了查询的操作行为,增加了查询的消耗</font>

## 14. change buffer

mysql进行数据更新时,如果更新的数据刚好在内存中,那么就直接更新,如果没有在内存中.就会先将更新的操作缓存在change buffer中.

`change buffer`实际更新数据的情况有以下几个情况

+ 下次访问该数据页的时候,会同时将`change buffer`中的数据进行执行从而使查找的数据获得更新
+ 定时自动将数据更新到磁盘的数据页上:`merge`操作

`change buffer`的职能本质就是减少磁盘的IO操作

`change buffer`用的是`buffer pool`中的内存空间,可以使用设置数据库参数`innodb_change_buffer_max_size`来指定change buffer可以占用的buffer pool的百分比空间

**使用场景**:写多读少的业务场景 .而对于如果业务场景中所有的更新操作后面都带着查询,那么建议关掉`change buffer`

所以在生产环境中,mysql是有一个内存命中率的概念(命中率越高,说明使用的操作越高效)

## 15. B+Tree能存多少数据（为什么两千万是公认的需要分表的大小数据）

先弄懂几个地方：这里描述的是聚簇索引且索引三层

第一个、mysql的存储单元是页。叶子节点存储的是数据页，而非叶子节点的存储数据是索引字段值+指针

第二个、页的默认大小是16K，一个bigint类型的主键id是8字节，指针是6字节



开始计算：

根节点只有一个，这个无容置疑，那么第二层的非叶子节点是多少个呢，也就取决于根节点中能有多少个指针指向第二层。也就是16*1024/(8+6)=1170。也就是说每个页能有1170个数据。那么第二层也就有了1170个单元数据

每页可以指向1170个数据单元。第二层可以有1170个数据，那么第三层的数据单元就是1170*1170=1368900个数据单元。这么多个数据单元也就对应着可以有这么多个页。那么总共的数据大小就是1368900x16k。假设一条数据是1k（一般假设就这么大）。那么就是1368900x16条数据=21902400。也就是两千万多一点

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/Bplus树存储的数据量.drawio.png)

## 16. innodb的排序（order by）

一般建议在需要排序的字段上建立索引，因为B+索引本身就是有序的，这样可以很迅速的完成整个结果的排序。

如果是在没有索引的字段上进行排序。那么innodb有两个实现方案

方案一：两遍扫描算法，将要排序的字段和其对应的指针先取出来到内存中进行排序，完成之后再对排好序的结构取出来所有的记录数据

方案二：将所有需要的数据取出来在内存中进行排序，这样会比较吃内存空间，但是性能较高。如果出现大量的数据查询出来超过预设的内存空间，就会采用方案一

## 17. 查询优化器

一条sql语句的执行方式有很多种，比如可以使用联合索引，也可以使用普通索引，也可以进行全表扫描。但是究竟是怎么进行会在查询优化器中进行决定。比如创建了索引，却没有使用，为什么呢。举个例子select. *from  tb where customer_id>1;这个情况，明明有customer_id的索引，但是使用explain关键字却发现没有使用索引，而且`possible_key`中显示了idx_customer_id但是key中却是空。因为我虽然检测到你是可以用索引的，但是我用索引还是会检测出来所有的数据，然后我还需要进行回表。这个还不如我直接全表扫描来的快。所以就选择了全表扫描



总结：查询优化器就是判断走最近的一条查询记录的方式。所以就会出现即使设置了所有也命中了，但是仍然没有使用的情况

### 「1」MyISAM和INNODB区别

InnoDb经过屡次优化,其实已经完全可以站在myIsam前面了

innoDb的优点

+ 支持事务
+ 支持表级锁,行级锁
+ 支持外键
+ 不会产生空间碎片

myIsam的优点

+ 支持全文索引

### 「2」锁类型

mysql锁分为共享锁(读锁)和排他锁(写锁)

共享锁,指锁情况下,允许进行其他的读操作.不允许写操作

排他锁,会阻塞其他的写锁和读锁

+ 表锁:会锁定整张表数据,在alter的时候会发生这个情况

+ 行锁

  + 悲观锁,顾名思义很悲观,每次进行数据操作的时候,都会加锁

    ```
    假设丢失更新一定存在；sql后面加上for update；这是数据库的一种机制。
    ```

  + 乐观锁

    认为操作的数据不会同时被别人操作,所以不会加锁,只是会执行后检查是否有存在修改的版本信息

### 「3」Undo log 和redo log

与事务有关的

undo log(记录的是原始数据) 、就是执行事务操作之前会将原始数据备份到log日志中.然后再进行数据修改,如果修改失败,这个时候就可以使用undo log进行数据恢复.**记录的是修改数据的原始数据**

redo log(记录的是新更新后的数据)、记录的是该事务更新的数据,也就是说需要更新的数据.在事务提交之前只需要持久化redo log即可,不需要持久化数据.

### 「4」分库分表

**什么是分区、分表、分库**

**分区**(使用partition关键字,多食用range的方式分区)

就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的，对业务透明，分区只不过把存放数据的文件分成了许多小块，根据一定的规则把数据文件(MYD)和索引文件（MYI）进行了分割，分区后的表呢，还是一张表。

**分表**

当数据量大到一定程度的时候，都会导致处理性能的不足，这个时候就没有办法了，只能进行分表处理。也就是把数据库当中数据根据按照分库原则分到多个数据表当中，这样，就可以把大表变成多个小表，不同的分表中数据不重复，从而提高处理效率。

**分库**

分表和分区都是基于同一个数据库里的数据分离技巧，对数据库性能有一定提升，但是随着业务数据量的增加，原来所有的数据都是在一个数据库上的，网络IO及文件IO都集中在一个数据库上的，因此CPU、内存、文件IO、网络IO都可能会成为系统瓶颈。

**雪花算法**

基于分库分表之后,常用的自增id的方式并不适用了,所以这个时候的id就需要使用一些特殊的规则来生成,比如雪花算法

实现

```
去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。

第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。
```

### 「5」explain关键字

`explain select * from student`

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/NnyVeR.jpg)

**id**

id相同,标识多个查询条件,从上至下依次执行

id不同,标识其中嵌套有**子查询**.id越大,越先执行	

**select_type**

表示查询的方式

SIMPLE：简单的select查询，查询中不包含subquery或者union；

PRIMARY：查询中若包含复杂的子查询，最外层查询则被标记为PRIMARY；

SUBQUERY：在select中或者where列表中包含的子查询；

DERIVED：在from列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表；

UNION：若第二个select出现在UNION后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED；

UNION RESULT：从UNION临时表检索结果的select；

select_type的作用：主要用于区分是否是子查询、联合查询、子查询等的复杂查询；

**table**

标识该条数据匹配的表

**type**

以上值从最好到最坏依次是：**system>const>eq_ref>ref>range>index>all**

1. system：表中只有一行记录（等于系统表），这就是const类型的特例，平时不会出现；
2. const：表示通过索引一次就可以找到，const用于比较primary key或者unique索引，因为只匹配一行数据，所以很快。如果主键置于where列表中，MySQL就能将查询转换成一个常量；
3. eq_ref：唯一性索引扫描，对于每个索引值，表中只有一条记录与之匹配，常用于主键或唯一索引扫描。
4. ref：非唯一性扫描，返回匹配某个结果单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体；
5. range：只检索指定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等查询，这种范围扫描索引比全表扫描要好，因为只需开始索引的某一点，而结束另一点，不用扫描全部索引。
6. index：Full Index Scan，index与all的区别就是index类型只遍历索引树，这通常比all要快，因为索引文件通常比数据文件要小（也就是说虽然all和index都是全表扫描，但index是从索引中读取，而all是从磁盘中读取）。
7. all:全局检查,没有匹配到任何索引信息

**possible_keys**

查询到的数据所在列的所有索引信息

比如*,会列出所有这张表的索引

**key**

当前查询语句使用到的索引

**key_len**

该条查询语句为**索引字段最大可能长度**

**ref**

显示索引那一列是否被使用,如果被使用,则为常数(const)

**rows**

大致估算出查询到数据所需要浏览的行数

Extra(前三者是SQL里最重要的指标）

**（1）Using filesort：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，MySQL中无法利用索引完成的排序操作称为"文件排序"；**

**（2）Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表，常出现在order by排序和group by分组查询中；**

**（3）Using index：表示相应的select操作中使用了覆盖索引（Covering index），避免了访问了表的数据行，效率不错。如果同时出现了Using where，表明索引被用来执行索引键值的查找；如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作；**

（4）Using where：表示查询使用了where条件；

（5）Using join buffer：表示查询使用了连接缓存；

（6）impossible where：where子句的值总是false，不能用来获取任何元祖；

（7）select tables optimized away：在没有group by 子句的情况下，基于索引优化min、max操作或者对于MyISAM存储引擎优化count(*)操作，不必到执行阶段在进行计算，查询执行计划生成的阶段即完成优化。

（8）ditinct：优化distinct操作，在找到第一匹配的元素即停止找同样的动作；

### 「6」count(*)、count(1)、count(column)的区别

***count(*)和count(1)**:返回获取的所有数据的总行数,包括数据为null的情况

**count(column)**:不会统计column字段为null的数据

### 「7」**是如何设计数据库的**

1. 首先设计数据库需要遵循三范式，即使不满足第三范式（由于业务逻辑的问题和查询效率问题），也一定要满足前两个范式
2. 最好使用UML建模来设计数据库的表。
3. 结构建立好了，还需要考虑性能问题，所以可以适当地建立索引

### 「8」为什么设计mysql要优化存储的数据结构

+ 空间上占用更小的空间
+ 在极限条件下,每行数据更小表明mysql的每页数据能存储更多的行数据,在一定条件下可以增加查询效率
+ 人为条件下也可以使用不同的数据类型来表示不同类型的存储情况,从而规范协作开发中的开发规范性问题

### 「9」为什么变长的varchar要尽可能小的符合业务需要

+ 在进行排序(需要临时空间)和创建临时表时申请临时空间,会使用指定的n来申请内存

### 「10」为什么字段尽量不要默认为null

1. 该列数据只要有一个是null,就会导致该列复合索引失效
2. null值干扰排序、分组、去重等结果
3. null值在进行复合函数的计算时会有问题
4. null不等同于空,在实际业务开发中会多出来一种逻辑

### 「11」一条sql语句是如何执行的

+ 参考极客时间《MySQL 实战45讲》的第一讲

### 「12」为什么要分库分表（高并发场景数据库如何设计）

单表的容纳上限有限制，不能太多。最大也就是到几百万，数据太多，`sql`性能太差

**并发量太高**，**数据量太高，查询速度太慢**

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/分库分表原理.png)

### 「13」用过哪些分库分表的中间件以及各自的特点

数据库中间件是获取数据，然后自己处理是将数据放在哪个表里面

常见的数据库中间件：cobar，TDDL，atlas，sharding-jdbc，mycat

proxy层：数据库独立部署在一台机器上的，需要相互通信

1. cobar，早些年使用，现在不使用了，不支持读写分离等
2. atlas，不维护了，不怎么使用了
3. <font color="red">mycat</font>：年轻，好用

client层：只是jar，所以也就是和系统是在一起的

1. TDDL，是淘宝团队开发的，不支持join，多表查询等语法。支持读写分离等。还依赖淘宝的diamond配置管理系统
2. <font color="red">sharding-jdbc</font>：很多大公司的使用，支持TCC事务

**比较sharding-jdbc和mycat**

前者由于是client层，所以不需要独立的部署或者维护。成本低。但是如果需要升级就比较麻烦。也就是耦合性很高

后者，有运维成本，但是proxy层所以和代码的耦合性不是很高。便于后期维护和重构

中小型建议使用sharding-jdbc。大型建议使用mycat（需要人手维护）

### 「14」如何对数据库进行垂直拆分和水平拆分（如何实现分库分表）



**「14.1 垂直拆分」**

拆分列（字段），将访问频率很高的字段拆出来。因为便于数据库缓存的使用

也就是将表拆开，订单表，订单详情表等

**「14.2 <font color="red">水平拆分</font>」**

一般我们说分库分表都是指水平拆分

1. 也就是将数据拆分开，将原本一个表中放的500万条数据，分给两个数据库中存放同样的表，但是每个表中只存储250万条数据
2. 将一个表拆成表结构一样**名字不一样**的的多个表，每个表中存储较少的数据



拆分方法可以是使用hash方法

>orderId%数据库的数量---->结果是多少就到对应的数据库中去
>
>比如有三个数据库。每个数据库中有四个表
>
>现在orderId是54
>
>分表的时候再进行一次
>
>54%3=0------到0号数据库中
>
>54%4==2-------到0号数据库的2号表中去
>
>优点是：可以分摊每个库的访问压力
>
>缺点是：扩容比较麻烦

拆分方法可以使用range方法

> 也就是按照时间来分。一段时间的数据放在一定的位置
>
> 好处是后期扩容的时候简单，只要预备好，给每个月都准备一个库就可以了。实际生产中使用range会看场景。有时候用户访问的并不是最新的数据，而是均匀访问时间的数据。这个时候就使用range的方法比较好



> 面试问你联合索引什么情况下会命中索引

+ 最左前缀原则

+ mysql也有自己校验的优化器,即如果判定走索引的消耗比全表扫描的消耗还大,就不会进行索引数据

  类似全表扫描只需要一次查询出来,但是如果使用非聚簇索引还需要进行非常多次的回表操作,这个时候就不会进行索引

> 常见的面试索引命中问题

表(a,b,c,d,e),index(b,c,d),primary(a)

| 查询语句                        | 是否使用索引 | 原因                                                         |
| ------------------------------- | ------------ | ------------------------------------------------------------ |
| select * from t where b>1       | 否           | 因为需要进行多次回表操作                                     |
| select a,b,c,d from t where b>1 | 是           | 查询条件在非聚簇索引上就可以获得,不需要回表                  |
| select b from t                 | 是           | 使用索引,但是是索引扫描.<br>因为索引存储数据量要小,所以分配的页少,<br>进行数据库的IO操作次数更少 |
| select * from t order by b,c,d  | 都可         | 不使用索引(数据量少):全表扫描,需要进行重新排序<br>数据量少时直接在内存中排序速度快,如果速度量过多内存不足<br>以构成排序操作就需要进行一些规则性的操作(比如一次比较一部分))<br>使用索引:不需要排序直接使用索引排序,需要大量的回表操作 |

> 普通索引和唯一索引

区别: 唯一索引指定的字段保证唯一性

性能分析:

**查询效率**


普通索引在索引命中第一条数据之后,还会在叶子节电继续往后面查询,直到查询到不是对应参数为止

唯一索引,命中第一条之后直接返回,不会再继续查询数据

但是在innoDB是按照页数据来查询,所以相邻的数据查询出来的消耗很小(不排除相邻两条数据刚好在不同页上的情况).所以上述区别微乎其微

**插入和更新效率**

唯一索引的特征:不允许索引字段重复

当数据在内存页中时:

+ 普通索引:找到位置,插入数据
+ 唯一索引:找到位置,判断是否重复,插入数据

当要插入的数据不在内存页中时:

+ 普通索引:更新记录到change buffer(没设计IO操作)
+ 唯一索引:从磁盘中获取到数据页,判断是否重复,插入这个值到磁盘中(涉及两次IO操作)

<font color="red">唯一索引不能使用change buffer</font>(因为需要校验是否会产生重复的数据,所以需要将磁盘中的数据查询到缓存中,这个操作就已经违背了change buffer的初衷(消耗更大),所以不会使用change buffer,而是查询出来直接更新)



> 如何选择联合索引的顺序

+ 数据区分度高的在左
+ 字段长度小的在左
+ 单独查询使用更频繁的放在左

> 查询数据少且频繁可以选择使用覆盖索引

这样减少回表的操作大大降低查询的时间

> 在线上环境设置索引需要遵循以下几点

1. 一般在初始化表时创建好索引信息
2. 如果在业务运行期间必须创建索引,应该选择业务量少的时候操作.索引的创建会造成锁表的情况
3. 绝对不能使用线下的客户端工具创建索引(例如navicat血淋淋的教训😭),使用命令创建
4. 高版本的mysql好像有异步设置索引的功能,具体未了解
5. online关键字可以在创建索引的时候使用非独占的方式创建



> 学习
>
> 诸葛老师讲的很干(干货满满):[诸葛老师bilibili](https://www.bilibili.com/video/BV1qb4y1Q7db?p=1&spm_id_from=pageDriver)
>
> 索引失效和优化:[张啊咩](https://www.cnblogs.com/amiezhang/p/10029901.html)

觉得不错点个赞呗,不然吐个槽呗

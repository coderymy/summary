# 1. String

## 1.1 特性

+ <font color="red">**不可变字符序列**</font>：不可变性，就是不会修改原本字符串的地址信息，重新赋值之后是重新创建了一个字符串

  + String a="abc"; String b="abc" a==b;   b="def";    a!=b（地址相同，修改成不一样的，就需要重新创建一个）

  + String a="abc"; String b=a+"def"    a!=b（在原有基础上修改了，就需要重新造一个）

    ```java
        String str = "abcd";
        char[] c = {'a', 'b', 'c', 'd'};
        
        public void change(String str, char[] c) {
            str = "efgh";
            c[0] = '0';
        }
        public static void main(String[] args) {
            HeapTest t=new HeapTest();
            t.change(t.str,t.c);
            System.out.println(t.str); //abcd
            System.out.println(t.c);  //0bcd
        }
    ```

+ 字符串常量池中不会存储相同的内容的字符串

  String 

+ 引用数据类型

+ 不可被继承：`public final class String`

+ 序列化：`implements Serializable`，自动实现了序列化，所以可以直接跨进程进行传输（类似Json）

+ 底层存储的结构：**JDK1.9之前使用的是`char[] value` **,**JDK1.9及其之后使用的是`byte[] value`**

  JDK1.9之前是char数组结构，之后是byte数组结构+编码标记

  修改原因：一个char=2个byte。一般一个英文字符，一个byte就能存储下。所以修改成byte[]。同时补充一个字符集约束，只针对类似英文字符/拉丁文字等。其他还是存储两个byte



## 1.2 底层结构

String 的String Pool是一个固定大小的HashTable，默认大小是1009（jdk6 默认1009 jdk7及之后默认 60013。jdk8要求最小值是1009）。相同hash的字符串是存储在同一个hash值的外接链表中的。



![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/String底层结构.drawio.png)

如果hash冲突过多导致链表长度过长，就会影响效率



## 1.3 String内存分配（在内存中放在哪）

JDK1.6 永久代中（永久代较小，垃圾回收频率较低）

JDK1.7之后放入堆中，统一管理实例对象内存。



## 1.4 字符串拼接

1. **常量和常量结果在常量池中**     在编译器进行拼接获取结果
2. **有一个变量   结果就存放在堆**中
3. 如果拼接结果调用了.intern()方法。就会将其放入常量池中（常量池中有就不放，没有就放）

```java
//带有变量的拼接方式：StringBuilder来进行拼接
String a = "a";   //"a"是常量，a是变量。此时放入了常量池中
String b = "b";   //"b"是常量，b是变量。此时放在常量池中
String ab = "ab";

String result = a + b;//此时相当于是new String("") 创建的一个result对象，计算结果在堆中
/*
底层实现步骤：
	1. StringBuilder stringBuilder=new StringBuilder;
	2. stringBuilder.append(a);
	3. stringBuilder.append(b);
	4. stringBuilder.toString();     相当于String result = new String(stringBuilder);
*/
System.out.println(ab==result);//false
//说明ab和result的地址不相同
```



```java
//不带变量的拼接方式  使用编译期优化
final String a="a";
final String b="b";
String ab="ab";
String result=a+b;

Sysrem.out.println(ab==result);//true
```

`final`修饰类、方法、基本数据类型、引用数据类型的时候，有些时候可以进行编译期优化



## 1.5 intern()

一个native的方法

**作用**：声明一个String对象，去常量池中查询是否该对象，如果不存在就将这个字符串放入常量池中（一判断二存入）

(在JDK7及其之后，同时会检查堆中是否有这个对象，如果有就直接在字符串常量池中保存堆中那个对象的地址)

`String s="蛋炒饭"`和`String s=new String("蛋炒饭").intern()`都会将“蛋炒饭”放入常量池中。（ps：String s=new String("蛋炒饭")会在堆中生成一个对象、在常量池中生成一个对象；并返回堆中生成对象的地址）



## 1.6 为什么要使用intern()，节省空间，垃圾回收

`arr[i]=new String(String.valueof(data[i].intern()))`

调用intern()的时候，会返回对应的字符串常量池中的地址信息。则数组中存储的就是字符串常量池中的地址信息。然后创建在堆中的字符串对象因为没有引用会被垃圾回收给回收掉。

1. 赋值的时候使用的是字符串常量的地址信息
2. 原本创建的堆中对象因为没有使用会被回收

总结：大量使用字符串的时候，推荐增加使用intern()来大大节省内存空间。

# 问题

## String_`new String("ab")`会创建几个对象

两个对象，可以通过字节码指令看出来

+ `new`的一个字符串对象，存放在堆空间中
+ 还有一个"ab"在常量池中的对象。



> new String("a")+new String("b")？
>
> 
>
> 1. StringBuilder 涉及拼接，就需要StringBuilder
> 2. new String("a")
> 3. ldc将"a"放入常量池中
> 4. new String("b")
> 5. ldc将"b"放入常量池中
> 6. 结果调用toString()方法：new String()。这里的toString()方法的调用，在字符串常量池中不会生成result
>
> **所以最终创建了六个对象。且不会在常量池中生成"ab"字符串对象**



## String_intern()方法的使用

```java
public class StringInternTest{
  	public static void main(String[] args){
      	String s=new String("1");//创建了对象，s中保存的是对象在堆中的地址信息
      	s.intern();//此时是将"1"放入字符串常量池中。但是已经有了，所以该操作相当于什么都没做，只是返回了字符串常量池中的地址信息。但是没有接收
      	String s2="1";//返回字符串常量池"1"的地址信息
      	System.out.println(s==s2);
      
      	String s3=new String("1")+new String("1");//创建了"1"的对象，并在常量池中生成了"1"（忽视上面）。创建了"11"的对象，将对象在堆中的地址赋值给了s3
      	s3.intern();//将"11"放到字符串常量池中
      	//JDK6，将"11"当到了永久代中的字符串常量池中
      	//JDK7～，欲要将"11"放到堆的字符串常量池中，但是发现堆空间中有"11"的对象，所以字符串常量池中记录的就是堆空间这个对象的地址信息
      	String s4="11";//获取字符串常量池中的"11"的地址信息
      	System.out.println(s3==s4);//JDK6-false，JDK7-true
    }
}
```

JDK6：false、false

s!=s2：s是通过new出来的，保存的是堆中的地址。s2是获取的"1"常量池中的地址

s3!=s4：s3经过intern()之后会在字符串常量池中创建"11"

JDK7/8及其之后（和6的区别就是字符串常量池从永久代到了堆中）：false 、true

s!=s2：s是通过new出来的，保存的是堆中的地址。s2是获取的"1"常量池中的地址

s3==s4：s3经过intern()之后发现堆中有这个对象，所以就直接在字符串常量池中记录的是堆中这个对象的地址信息

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/字符串常量池.drawio.png)

## Comparable和Comparator的区别

## Comparable是什么

> 简介：实现该接口的类可以进行自比较

自比较：自己对象本身和参数进行比较

一个接口，实现了这个接口的类对象可以根据接口的方法compareTo进行比较来获取比较结果。同时这些对象可以被增加到Collaction集合中，使用`Collections.sort(xxx)`进行排序

```java
/**
 * 实现一个业务逻辑
 * 多张优惠券。
 * 1，金额大的在前面
 * 2，金额相同时，距离有效期最近的在前面
 * 3，前两个结果相同时，id小的在前面
 */
public class ComparableDemo {
    public static void main(String[] args) {
        List<Coupon> coupons = new ArrayList<>();
        //添加了一堆coupon。然后调用下面方法就可以对coupon进行排序。这个方法参数必须是实现了Comparable接口并按照业务实现了compareTo方法
        Collections.sort(coupons);
    }
}

@Data
class Coupon implements Comparable<Coupon> {
    private String id;
    private Date endTime;
    private int price;

    @Override
    public int compareTo(Coupon o) {
        if (o.getPrice() > this.price) {
            return 1;
        } else if (o.getPrice() == this.price) {
            if (this.endTime.compareTo(o.getEndTime()) == 0) {
                return id.compareTo(o.getId());
            } else {
                return this.endTime.compareTo(o.getEndTime());
            }
        } else {
            return -1;
        }
    }
}
```



## Comparator是什么

> 简介：可以辅助比较没有实现/想重写对方实现方法Comparable接口的对象进行比较

作用场景一般是

+ 预比较的对象没有实现Comparable接口或者实现的compareTo逻辑不是自己想要的，而且无法使用继承来实现（final）

比如我觉得String的自比较方式我不喜欢，那么就可以

```java
class Express implements Comparator<String> {
    public static void main(String[] args) {
        List<String> strings = new ArrayList<>();
        //表示不使用String自带的compareTo方法而是使用Express对象中的比较方法
        Collections.sort(strings, new Express());
    }
    @Override
    public int compare(String o1, String o2) {
        //xxxx各种逻辑实现
        return 0;
    }
}
```

## 两者的区别

Comparable侧重于**自比较**。也就是对象本身和一个对象的比较。compareTo方法参数是一个对象。

业务场景：将优惠券排序。

Comparator侧重于**外比较**，就像是帮助别人进行比较一样

业务场景：对名称排序（有时候想按照首字母的拼音排序，有时候想按首字母的笔画排序。）这个时候就可以创建多个类实现Comparator接口。



共同点：都可以使用Collections.sort()方法来对集合对象进行排序。



## 扩展TreeMap

相较于HashMap，TreeMap的主要特点在于可以比较元素的大小。在进行put的时候进行排序。其原理就是在创建Map的时候传入了一个比较器。在put方法的时候会调用这个比较器进行比较

```java
Map<String, String> map2 = new TreeMap<String, String>(
                new Comparator<String>() {
                    public int compare(String obj1, String obj2) {
                        //升序排序（反过来就是降序排序）
                        return obj1.compareTo(obj2);
                    }
                });
```

其中实现的逻辑可以用来进行比较；下面进行put的时候就会自动按照比较结果进行排序。






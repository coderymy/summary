# HashMap底层原理结构分析

## Jdk7的HashMap

数组和链表上存储的是Entry的对象（对象中包含Key和value）

在进行数据插入的时候，对数据进行取模运算，来存储在**数组**的一个节点上。如果发现取模结果的节点已经存在，就在这个节点之后的**链表**上往后增加数据，如果一条链表的数据超过了八个，就会转变成**红黑树**（少于6个转换成链表）

四大方法**hash**、**get**、**put**、**resize**（扩容）

put：
```java
    
    public V put(K key, V value) {
        //先进行hash操作
        return putVal(hash(key), key, value, false, true);
    }

    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        //tab：就是数组，p：是数组上链接的那个链表的首节点，n：是数组的长度，i：是hash取模后的下标
        HashMap.Node<K,V>[] tab; HashMap.Node<K,V> p; int n, i;
        //如果是空的时候就进行初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //如果要插入的数组下标节点的链表是空的就会创建一个链表
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        //不为空的链表就直接在链表上进行操作
        else {
            HashMap.Node<K,V> e; K k;
            //如果当前的k-v与首节点哈希值和key都相等，赋值p->e，也就是插入的是同一个key就进行更新操作即可
            if (p.hash == hash &&
                    ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            //结构为红黑树，则按照红黑树的方式进行添加
            else if (p instanceof HashMap.TreeNode)
                e = ((HashMap.TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            //遍历整个链表来找到最后的节点进行增加元素
            else {
                //1。 遍历整个链表
                for (int binCount = 0; ; ++binCount) {
                    //2。 如果是找到了最后的节点还没跳出整个循环则将数据添加到尾节点上，即next==null
                    if ((e = p.next) == null) {
                        //3。 创建新的节点
                        p.next = newNode(hash, key, value, null);
                        //4。 如果链表的长度超过了8（上面是先遍历后+所以这个地方判断是否>=7）将链表转变成红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            //4。1将链表转变成红黑树
                            treeifyBin(tab, hash);
                        break;
                    }
                    //当前遍历到的节点e的哈希值和key与k-v的相等则退出循环，因为这里只处理新增（一般不会出现这种情况，应该在上面就已经拦截住了）
                    if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    //当前节点e不为尾结点，将e->p，继续遍历
                    p = e;
                }
            }
            //处理更新操作，新值换旧值
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        //如果当前map中包含的k-v键值数超过了阈值threshold则扩容resize
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
```
结论：
1. 如果链表长度超过8则转换成红黑树：`if (binCount >= TREEIFY_THRESHOLD - 1)  treeifyBin(tab, hash); `
2. 如果数组元素超过阀值则进行扩容；默认值：`(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)`即 16*0.75=12；`if (++size > threshold) resize();`
3. 先将key进行hash（(h = key.hashCode()) ^ (h >>> 16)）也就是先将原始值右移16位然后再和原始值进行异或处理，这样做的目的就是为了将16位数字全部参加运算（相当于这个数值是完整的32位操作得出来的）这样可以降低hash冲突的可能性。 ![](https://img2020.cnblogs.com/blog/1162587/202011/1162587-20201113150824675-137769143.png)

![借用大佬的一张流程图](https://img-blog.csdnimg.cn/20181105181728652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvc2hpbWF4aWFvMQ==,size_16,color_FFFFFF,t_70)

resize：


1. 将原数组的大小和阀值扩大至两倍大小
2. 将原数组中的元素下标按照新数组的长度哈希运算hash&(newCap - 1)定位到新的下标位置
3. 原数组如果是红黑树的结构转到新数组中下标肯定会变，如果对应的红黑树节点少于6就会转换成链表
4. 数组的结构是连续的一片空间，所以没办法像链表结构一样随用随取，所以在达到了一定的空间使用之后就需要进行resize操作开辟一块新的空间将原数组迁移过来


# ConcurrentHashMap底层结构分析

我们知道最基础的ConcurrentHashMap和HashMap的区别在于前者是线程安全的。那什么是线程安全，就是多个线程对一个资源或者一个数据进行访问的时候得遵循加锁原则也就是只有上一个访问完成之后才允许下一个访问

<font color="red">**Java7**</font>及其之前：

![](https://img-blog.csdnimg.cn/img_convert/5cd777c30769ab49c24de982c53d0af9.png)

其中有一个Segment的概念，使用分段锁的概念（一个Segment就是一个分段锁，一个线程访问一个Segment的时候不会影响到其他的Segment的操作）




<font color="red">**Java8**</font>之后：
1. 加锁范围尽量的小，抛弃了Segment的概念而采用CAS + synchronized来保证线程安全
2. 也和HashMap的优化一样增加了红黑树来协助取数据链表的速度慢的问题
3. 扩容
4. 将原本的HashEntry 改为 Node。其中的val next 都用了 volatile
5. 




# 学习自以下大佬，支持原创

1. [HashMap](https://blog.csdn.net/woshimaxiao1/article/details/83661464)
2. [ConcurrentHashMap](https://www.cnblogs.com/jajian/p/10385377.html)
3. [HashMap](https://www.cnblogs.com/jajian/p/13965678.html)
4. [ConcurrentHashMap](https://blog.csdn.net/weixin_44460333/article/details/86770169)


# 1. 概念

首先需要理解几个概念

> MVCC

mvcc:多版本并发控制	

> 当前读和快照读

当前读:会对读取的信息进行加锁的操作

+ 加锁的select操作,比如后面加上关键字`for update`
+ update、insert、delete操作等

快照读:不加锁的一种非阻塞读操作,

+ `不加锁`的select操作



事务的四种隔离级别中

+ 读已提交
+ 可重复读

都是基于MVCC实现的

串行化,因为是基于一步一步操作执行的,这个时候就必须是用到了锁来限制.所以这个串行化是使用当前读实现的

## mvcc的结构:

+ 版本链
+ undo log
+ readview:是去判断版本链中select有效的哪个版本

![](img/MVCC中概念点.png)

在每执行一步快照读操作的时候,执行的字段中包含上面描述的`事务ID`,和`版本回滚指针`

readView的工作模式

```
readview中有四个字段描述
+ m_ids:生成该条readview时当前系统中活跃的读写事务的`事务id`列表.活跃的事务id指的是未commit的事务id
+ min_trx_id:readview中最小的`事务id`
+ max_trx_id:readview时系统分配给下一个事务的id值
+ creator_trx_id:表示生成该条readview的事务id
```

# 2. why to use MVCC

一般需要并发操作有三个场景

+ 读-读:不涉及数据变更,是不会有并发冲突的
+ 读-写:有可能会出现`脏读、重复读、幻读`
+ 写-写:有可能出现更新失败的情况

mvcc就是为了解决第二种`读-写`操作会需要频繁使用锁机制来保证并发冲突情况的另一种解决办法

以此防止使用锁机制造成效率的下降



# 3. how to use MVCC

1. 借助undo log实现.每条undo log中多两个字段,表示出来`事务id`和`版本回滚指针`
2. 使用readview定位到select操作应该执行的版本信息



# 4. 问题

1. 当前读和快照读在RR下的区别

   ```
   当前读并不需要进行一个串性的操作,而是各个语句的执行相互嵌套
   快照读需要串性的锁来管控
   ```

2. #### RC,RR级别下的InnoDB快照读有什么不同？

   ```
   正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同
   
   在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；
   而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。
   ```

   
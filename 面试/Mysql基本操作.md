# 0.学习

[MySQL优化/面试，看这一篇就够了](https://www.nowcoder.com/discuss/150059?type=0&order=0&pos=13&page=0)

# Mysql的基本使用

## 表结构操作

```
1. 创建表
	create table <表名> (
		<字段名> <类型> [列级别约束] [默认值] [注释],
		<字段名> <类型> [列级别约束] [默认值] [注释],
		CONSTRAINT <约束名> FOREIGN KEY (A表的X字段名) REFERENCES B表(Y字段),
		[表级别约束]
	)[engine=引擎][default charset=字符集]
	CREATE TABLE `testdemo1`(
	`uid` INT PRIMARY KEY AUTO_INCREMENT,
	`username` VARCHAR(20) NOT NULL ,
	`password` VARCHAR(20) NOT NULL
	);
	
2. 主键约束
	1. Primary key
	2. 如果是联合主键，可以在表的创建结尾部分使用以下方式创建
		PRIMARY KEY(字段一，字段二)
3. 外键约束（reference）
	1. 在创建列的时候使用以下方式加上外键约束
		字段名 类型 REFERENCES B表(X字段)
	2. 在表创建尾部使用
		CONSTRAINT <约束名> FOREIGN KEY (A表的X字段名) REFERENCES B表(Y字段)
4. 复制表操作
	CREATE TABLE testdemo2 AS SELECT * FROM testdemo1;
5. 修改表
	alter table XXX XXXXXXXXXXX
6. 创建删除索引
	create index 索引名 on 表名(字段名)
	drop index 索引名;
```

> 约束条件

1. 主键约束
    PRIMARY KEY
2. 自动递增	
    auto_increment
3. 外键约束	
    REFERENCE，reference

## 2. 增删改查

### 2.1 增

```
insert into 表名(字段名1，字段名2，字段名3) values(值1，值2，值3);
```

### 2.2 删

```
delete from 表名 where 条件
```

### 2.3 改

```
update table set 列名1=值1，列名2=值2，where 条件
```

### 2.4 查

> #### 单表查询
>
> 1. 排序
>
> ```
> select * from 表名 order by 列名 DESC/ASC
> ```
>
> 2. IN
>
> ```
> select * from 表名 列名 in (值1，值2，值...)
> ```
>
> 3. 模糊查询 
>
> ```
> select * from 表名 列名 like 通配符
> 
> ```
>
> %. 表示匹配出现的任意次数的任意字符
>
> _. 匹配一个字符
>
> 4. 聚合函数，也就是在查询的信息中使用
>
> > 1. AUG()，平均值
> >
> > ```
> > select AUG(uid) from 表名
> > 
> > ```
> >
> > 2. COUNT()，某列数量
> > 3. MAX
> > 4. ()，某列最大值
> > 5. MIN()，某列最小值
> > 6. SUM()，某列的和
>
> 5. 分组查询
>
> > GROUP BY，表示分成什么组
>
> 6. HAVING子句
>
> 用于指定组所对应的条件，也就是可以是聚合函数。这就是和where的唯一区别，都是作为一种条件判断使用的
>
> 7. LIMIT子句
>
> 表示分页查询，指定

> #### 关联表查询
>
> 1. 基本使用
>
> ```
> select * from 表1,表2 where 主表.主键=从表.外键 and 其它过滤条件 
> ```
>
> 2. 内连接
>
> ```
> SELECT 主表.列1, ..., 从表.列1, ... FROM 主表 INNER JOIN 从表 ON 主表.主键 = 从表.外键 WHERE 过滤条件;
> 也就是在以前的基础上，在两个表中间加上了"inner join" 后面的链接条件加上"on"
> ```
>
> 3. 左外连接
>
> ```
> SELECT * FROM ... 
> LEFT JOIN ... ON ... = ...
> WHERE ...;
> 
> 和自连接的区别在于使用"left join"
> ```
>
> 4. 右外连接
>
> ```
> SELECT * FROM ... 
> RIGHT JOIN ... ON ... = ...
> WHERE ...;
> 
> 区别在于使用 "right join"
> 
> ```
>
> 5. 自连接
>
> 关键是使用别名



# 2. 分库分表

## 大表优化

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

### 1. 限定数据的范围

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

### 2. 读/写分离

经典的数据库拆分方案，主库负责写，从库负责读；

### 3. 垂直分区

 **根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

 **简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。
 ![数据库垂直分区](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数据库垂直分区.png)

- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

### 4. 水平分区

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。** 

 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

![数据库水平拆分](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数据库水平拆分.png)

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决**  ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案：**

- **客户端代理：**  **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。
- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。

详细内容可以参考： MySQL大表优化方案: [https://segmentfault.com/a/1190000006158186](https://segmentfault.com/a/1190000006158186)

> 问题

+ 什么叫做垂直拆分,什么叫做水平拆分

  水平拆分,表结构是一致的,业务数据不一样而已

  垂直拆分,表结构不一致.业务数据多张表统一管理一个用户

+ 分库分表中间件的使用

+ 如何做到线上动态的从未分库分表切换成分库分表的形式

+ 如何解决分页问题

+ 主键id不能使用自增主键(雪花算法、全局主键等),sharding-jdbc自带解决方案

主从复制的主从同步延时问题

使用`show status`查看Seconds_Behind_Master结果,即从库延时的时间

## Sharding-JDBC

1. 配置jar文件

2. 配置**数据源**

3. 配置**表数据的分布情况**,即t_order操作哪些表(例:spring.shardingsphere.sharding.tables.t_order.actual-data-nodes=m1.t_order_$->{1..2}标识使用m1这个数据源的表开头为t_order_之后的其他数据)

4. 配置**主键生成策略**SNOWFLAKE

5. 配置表**分片策略及分片算法**.即后续如何找到对应的表的数据

   ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/hrtlss.jpg)

​	
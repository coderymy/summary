# LRU缓存淘汰算法


**单纯使用链表实现LRU**

维护一个按照访问时间从大到小有序排列的链表结构。

1. 淘汰:因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。
2. 缓存:每次新增一个缓存数据,都遍历链表是否存在该数据,如果存在就将该数据移动到链表尾部,如果不存在就在链表尾部增加该数据
3. 查找:遍历整个链表,并将查询到的数据移动到链表尾部


以上三步操作都有**查找**的操作,所以时间复杂度是O(n)

**使用散列表和双向链表实现**

![](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

这里一个节点包含四个数据
1. data,存储数据
2. prev,前置节点的地址信息
3. next,后置节点的地址信息
4. hnext,当前散列表链表的下一个节点的地址信息

这里理解下next和hnext的区别.如图所示,next是将所有的数据都串成一个链表.而hnext只是因为解决散列表冲突时使用链表法,这里的一个一个相同hashCode的链表.

**使用**

1. 查找:<br/>
    查找操作与正常的散列表查找一致,计算出hashCode.在对应的链表上进行遍历即可
2. 删除:<br/>
    首先使用上述方法找到节点,删除因为是链表操作,所以只需要操作上一个和下一个指针地址指向即可删除.时间复杂度O(n)
3. 添加:<br/>
    其实也就是正常的链表添加操作,因为可以直接基于hash表的操作来判断是否存在,所以这个验证操作很简单<br/>
    验证之后不存在就直接在尾部添加,存在就操作链表的前后指针将该节点移到链表尾部(并不是变更地址空间,只是操作指针指向).同时这个地方还得判断是否已满,满了就将头节点删除


# LinkedHashMap

这里的Linked并不是指hashMap使用链表来解决hash冲突的问题.而是说数组下每个槽中的链表实现是双向链表,这些双向链表与别的槽中的节点相互链接可以组成一条完整的双向链表.

这个数据结构与散列表中hashMap的那张图很相似

而每个槽中的节点也有链表的指针来将其串起来.


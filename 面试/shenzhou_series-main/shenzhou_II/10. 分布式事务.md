# 1. 分布式事务产生的背景

1. 传统项目

   > 传统项目在项目中使用多数据源的时候可能会产生分布式事务的问题
   >
   > 多数据源：就是在一个项目中使用多个jdbc连接。通过分包或者注解方式。

2. 微服务项目

   每个服务都有自己独立的数据库，并且是独立运行的，互不影响。

   服务与服务之间通讯采用RPC远程调用技术，但是每个服务中都有自己独立的数据源，即自己独立的本地事务，两个服务相互通讯时两个事务互不影响。

在分布式事务中，**<font color="red">下单和扣库存</font>**

这两个功能必须保持一致。也就是按照事务的特点就是。下单和扣库存必须同时执行或者都不执行。但是又是在多个微服务中，所以这个时候就涉及到了分布式事务

在秒杀的时候，又会涉及到超卖的问题，所以这个东西和秒杀是相关联的

**订单服务**和**库存服务**

```sequence
title:"下单和扣库存"
订单服务-->库存服务:使用feign调用库存的方法，使库存减去100件苹果
订单服务-->订单服务:系统出现错误，下面本该执行订单下单的代码没有执行
```

这个时候就出现了，库存减了但是没有进行下单

**总结**：分布式事务解决的问题就是

> <font color="green">两个服务之间调用，但是由于系统故障，只执行了一个服务中的代码，另一个服务没有执行完成，但是调用已经开始了。所以这个时候就会出现与预期情况不一致。也就是违反了事务的一致性的特性</font>







# 2. 解决分布式事务基本思想Base和CAP理论

## 2.1 Base理论

1. 基本可用，在系统发生故障的时候，允许损失部分可用性，保证核心的可用
2. 软状态
3. 最终一致性

最终一致性：支付项目：

> ```sequence
> title:"同步回调地址"
> 淘宝-->支付宝:告诉支付宝去扣去十块钱
> 支付宝-->淘宝:逻辑执行完成之后会使用浏览器的方式（重定向）告诉淘宝执行完成了
> 淘宝-->淘宝:继续执行下面的业务
> ```
>
> ```sequence
> title:"异步回调地址"
> 淘宝-->支付宝:告诉支付宝去扣去十块钱
> 支付宝-->淘宝:扣去完成之后，发送一个http请求到淘宝的url，告诉执行完成
> 淘宝-->淘宝:继续执行下面的代码
> ```

最终一致性就相当于异步回调地址，也就是说，这次请求结束，结果可能不一致。但是最终支付宝总会告诉我支付完成，然后我这边给出货物。最后还是一致的。

总结：最终一致性就是，可能这次服务的请求后，支付宝那里进行了扣款，但是还没来得及发送请求告诉淘宝进行后续处理。所以这个短暂的时间会会导致数据不一致。并没有保证这个数据保持事务的一致性。但是最后整个业务执行完完成，还是会保持一致的

一般来说，都是使用异步回调地址。因为支付宝的访问量太大，不可能实时的保证接收到的请求立马就能获取到系统资源来执行。所以为了不影响第三方业务，一般都会使用异步的情况



## 2.2 CAP理论

C：表示一致性，分布式双方进行通信，要保持数据的一致性问题。

A：可用性，也就是高可用的概念

P：分区容错性，网络即使丢失一些数据，但是整个系统仍然可以继续工作的。

一般都尽力去遵循A和P。C可以不遵循来换取A





# 3. 柔性事务和刚性事务的区别

柔性事务满足BASE理论（基本可用、最终一致）

刚性事务满足ACID（一致性，持久性，隔离性，原子性）







# 4. 解决分布式事务核心思想软状态与最终一致性思想

见上述

# 5. 分布式事务常见解决方案

## 5.1 传统模式使用Jta+Atmikos

两阶段提交协议

第一阶段提交：协调者会向参与者发送一个指令，如果参与者收到指令后，都会把该业务逻辑是否执行成功返回给协调者

如果参与者都返回执行成功，协调会在第二阶段发送提交事务通知，如果有一方返回执行失败，就会终止提交

总结：

>对于支付宝和淘宝之间的业务
>
>```sequence
>淘宝->支付宝:第一阶段，去账户中扣十块钱
>支付宝->淘宝:已经准备好了扣款
>淘宝->支付宝:第二阶段，去完成你的事务
>支付宝->淘宝:已经完成了事务
>淘宝->淘宝:完成这个事务
>```
>
>![1570629686039](C:\Users\coderymy\AppData\Roaming\Typora\typora-user-images\1570629686039.png)

## 5.2 2Pc和3Pc实现的区别

三阶段提交相较于两阶段，增加了一个提前尝试的操作

两阶段：prepare-confirm/rollback

三阶段：CanCommit？PreCommit？confirm/rollback。

try第一步的目的在于确定两个服务器之间的通信畅通无阻（一些网络、接口对等、端口服务等规则性的校验）

prepare第二部的目的在于进行业务信息的校验，比如我有没有100元钱？我就要转100元给别人。或者我给我的资源加个锁之类的

第三步是进行真实的业务操作，我从我账户扣除了100元，别人账户真实的增加了100元或者给资源解锁等

## 5.3 *使用阿里巴巴TCC补偿框架*

## 5.4 使用可靠性消息模式

## 5.5 使用LGN框架解决分布式事务（重点）

## 5.6 使用阿里GTS框架解决分布式事务

# 6. 分布式事务实现方案

## 1. 两阶段提交方案（XA事务）

<font color="red">1. 询问</font>

<font color="red">2. 执行</font>

<font color="red">例子：</font>

>群主在群里问其它三个人“去打麻将？”，然后群主等待所有人私聊他，查看是否所有人都OK。如果都OK，就确定活动（commit）。如果有一个人不OK，就通知其它所有人，**不去了(rollback)**。
>
>第一阶段：询问并等待所有人的确认。一旦所有人都OK，就执行下一阶段（就开启事务）
>
>第二阶段：去活动（执行事务）。

<font color="red">概念</font>：

> 也就是说，**事务管理器**，先发讯号询问每一个**参与者**，是否能参与这个行为。当所有人都确定能参与这个行为之后。**事务管理器**就开启事务，然后每个人就执行事务，执行完成该事务就完成了
>
> 阶段一：询问
>
> 阶段二：执行

<font color="red">场景</font>：一个系统操作多个数据库

<font color="red">操作方式：</font>Spring+JTA

<font color="red">实际</font>：很少用，因为微服务架构中，**规范**是每个服务只能操作自己的数据库，如果需要操作别的数据库中的数据。一般都是调用别的服务的接口来执行的。所以这就不和**二阶段提交方案的原理**相一致了。

## 2. TCC方案（Try+Confirm+Cancel）

【1】Try阶段：对每个服务的资源进行**检查**，**锁定**或者**预留**。

【2】Confirm阶段：让每个服务执行对应的操作

【3】Cancel阶段：就是如果一个服务的业务方法执行失败，就进行补偿。也就是执行已经执行的操作的<font color="yellow">回滚操作</font>

<font color="red">例子：</font>

> 银行转账：
>
> Try阶段：通知转账银行，查看是否有这么多钱，将这些钱冻结，不允许再进行其他操作。通知被转银行账户，不要继续使用别的操作
>
> Confirm阶段：将转账银行账户扣款，给被转银行账户加款
>
> Cancel阶段：如果上一个阶段出现任何问题。将扣除的钱和加上的钱都**回滚**

<font color="red">概念</font>：也就是执行业务之前先进行**检查**，查看能否执行这样的操作并**冻结**一些信息。检查完毕之后再进行对应的操作。一旦操作期间出现任何问题，就进行回滚

<font color="red">场景</font>：使用的比较少。因为需要很高的耦合性业务（比如Try的时候Cancel的时候），所以就是所有的代码都不可能重用。所以适合的场景，就要求分布式业务要求很高的时候会使用，比如说<font color="red">金融，财产，资金</font>相关的一些业务

<font color="red">特点</font>：严格，和业务逻辑耦合性很高。一般使用在和钱有关的业务中

## 3. 本地消息表

<font color="red">原理</font>：（有些麻烦）


【1】A系统需要操作一个行为，就向本地数据库的业务表中插入一个信息，再想本地消息表中插入一个信息。

【2】然后A系统向MQ生产一个信息，B系统来消费这个信息。

【3】B系统消费信息之后，先操作自己的本地数据库的消息表，插入这个信息（防止多次消费同一个信息），然后再操作业务表

【4】系统A使用Zookeeper来监听协调B系统的信息。一旦B系统执行完成之后，就触发事件监听，让A知道B执行完成了。

【5】如果A一直监听不到B系统的成功的信息，过一段时间A就再次发送一个信息供B消费。以此执行下去

<font color="red">重点理解几个地方</font>：

1. 使用消息表这个概念
2. 使用Zookeeper进行事件监听的协调
3. 使用MQ进行消息的传递

缺点：并发量大的话，保存消息表很耗资源

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/本地消息表.png)

## 4. 可靠消息最终一致性（<font color="red">最重要</font>）

基于本地消息表改造的。阿里的**<font color="blue">RocketMQ</font>**支持消息事务，结合这个就可以实现

<font color="red">原理</font>：

【1】A系统发送prepared消息到RocketMQ

【2】然后A系统开始执行事务代码

​	【2-1】A系统执行成功，就给RocketMQ发送一个confirm消。一旦发送这个消息，MQ就会让B系统消费这个消息

​	【2-2】A系统执行失败，就会发送到RocketMQ进行刚才的prepared消息回滚操作

【3】B系统消费到这个消息，就开始执行自己的事务

【异常情况：】

​		【1】A系统发送confirm消息失败，RocketMQ一段时间没有接收到发送prepared消息的A系统的confirm消息（也就是没有接收到对应那个系统的confirm消息），它会回调A系统的接口询问是回滚还是重新发送confirm--->一定要让这个confirm成功，因为本地事务已经执行了，所以必须B系统的事务也执行

​		【2】B系统执行业务失败。需要系统自己进行不断的重试。失败可以通知MQ重新发送一次供他消费。也可以使用`Zookeeper`来执行一些操作告诉A系统--->总之就是，失败了就一直反复重发来执行

​		【3】B系统保证自己的幂等性，保证执行成功或者执行失败，能有一个确定的方式

​				【3-1】保存在数据库中

​				【3-2】保存在ZK中

<font color="red">总结</font>：这个方式保证的是**最终的消息一致性**，也就是重点就是保证最终B系统的消息与A系统的消息保证一致性

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/可靠消息最终一致性.png)



## 5. 最大努力通知方案

<font color="red">原理</font>：在MQ与消费者之间设置**最大努力通知服务**，只是尽力去保证消息一致性。实在不行就算了，所以并不是很全面的进行通知

场景：一般使用在不是非常严格的场景下。比如说记录日志信息





# 2pc(一般针对多数据源)

+ 准备阶段,这个阶段其实就是执行业务操作.但是业务操作并不提交事务
+ 提交/回滚阶段,进行事务的提交和回滚

这里准备阶段就进行了整体业务逻辑的操作.

举例子:银行转账A->B

第一阶段:

​	访问A,询问是否有30元,如果有就扣除三十元

​	访问B,增加三十元

第二阶段:

​	访问A,提交数据库修改

​	访问B,提交数据库修改

# Tcc(一般针对多服务)

本质是两阶段提交：

1. **Try** 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 Conﬁrm 一起才能真正构成一个完整的业务逻辑。
2. **Confirm** 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，需引入重试机制或人工处理。
3. **Cancel** 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。

TCC与2PC不同的是,不能保证强一致性(try成功就认定confirm一定成功)

+ Tcc这里**Try**要求的是确保信息资源能够执行后续的**Confirm**操作.
+ 2pc的一阶段其实是执行业务操作,只是不提交



举例子:银行转账A->B

Try:

​	访问A,判断账户是否存在,账户上是否有三十元,如果有锁定账户余额信息

​	访问B,判断账户是否存在

confirm:

​	访问A,扣除三十元,并提交事务

​	访问B,增加三十元,并提交事务

cancel:

​	访问A,接触余额锁定

​	访问B,无



# rocketMq如何实现可靠消息最终一致性

最终一致性

![](img/9d473daf5cc54c0d04bd29e08125a1f0.JPEG)

1. A服务也就是发送方发送half message 到 broker服务端
2. 当A服务指导半消息发送成功后，开始执行本地事务
3. 执行本地事务会有三种情况(1,执行成功 2，执行失败 3，网络等原因没有响应)
   - 如果执行成功，返回commit
   - 如果执行失败，返回rollback
   - 如果没有收到响应，那么回查事务状态
4. 根据事务的状态执行操作
   - 如果commit，那么提交到订阅方
   - 如果rollback，那么不投递消息，三天后删除
   - 如果没有收到确认，那么回查事务状态



# XA与TCC的区别

两者并不是同一个东西。

XA是所有分布式事务的基础，也就相当于他本身就是一个事务的实现。他的标准在于Mysql的prepare-commit-rollback。整个事务过程中数据都处于锁定状态

TCC是一种XA在分布式环境下的落地实现，他的每一步可能都涉及到XA的行为。而从宏观的角度来看，整个TCC的行为也是一个XA的实现
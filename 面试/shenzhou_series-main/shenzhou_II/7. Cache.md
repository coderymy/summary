# 1、客户端缓存

## Ehcache

+ 多级缓存
+ 可以写入磁盘中
+ 缓存数据在虚拟机重启时写入磁盘
+ 可以通过RMI或接口的方式实现分布式缓存
+ 有监听机制
+ 重量级



## Guava Cache

+ 轻量级

## Spring Cache

+ 基于Spring，使用便捷
+ 支持AspectJ

SpringCache的核心是作用在方法上的。也就是调用一个方法的参数如果一致就会直接获得上次返回的结果

使用方式

1. 配置Spring支持cache
2. 在方法上使用注解声明使用缓存



关键注解

+ @EnableCaching：开启缓存功能。作用在启动类上
+ **@Cacheable**：定义缓存，用于触发缓存
+ **@CachePut**：更新缓存。也就是触发缓存的更新
+ **@CacheEvict**：清除缓存，触发缓存清除
+ @Caching：组合定义多种缓存功能
+ @CacheConfig：缓存配置

```java
@Service
public class CacheService {
    @Resource
    ShowActivityMapper showActivityMapper;
    @Cacheable(value = "showActivity")// 保存缓存到key为showActivity中
    public List<ShowActivity> getShowActivityMsg() {
        List<ShowActivity> showActivities = showActivityMapper.listByActivityIdAndActivityName(null, "蛋炒饭");
        return showActivities;
    }
    @CachePut(value = "showActivity")//更新key为showActivity的缓存数据为该方法的返回结果
    public List<ShowActivity> addShowActivity(Integer id, Integer status) {
        showActivityMapper.changeStatus(id, status);
        return showActivityMapper.listByActivityIdAndActivityName(id, null);
    }
    @CacheEvict(value = "showActivity")//删除key为showActivity的缓存数据
    public List<ShowActivity> delete() {
        return null;
    }
}

```





# 2、redis

## 2.1、线程模型

![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/FZ4T9G.jpg)



![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/248uVa.jpg)

1. Server socket 监听到客户端发的请求,会产生一个AE_REABLE的事件
2. IO多路复用程序将AE_REABLE事件压入队列中,依次执行
3. <font color='red'>文件事件分派器</font>从队列中取数据交给<font color='red'>链接应答处理器</font>
4. 链接应答处理器创建与客户端的长链接socket,并将这个长链接和需要执行的命令给到<font color='red'>命令请求处理器</font>
5. 命令请求处理器进行命令执行,执行完成之后将socket的长链接与<font color='red'>命令回复处理器</font>关联
6. 文件事件分派器使用对应的socket关联与命令回复处理器的执行断开socket请求

线程模型的意义

1. 使用非阻塞IO多路复用程序,所以支持高并发
2. 使用的文件事件分派器是单线程的,所以redis是单线程的


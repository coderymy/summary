# 概念



## 简述类加载过程

+ 加载：将类从硬盘上加载到内存中的过程
+ 连接
  + 验证：验证字节码文件是否合法且不会破坏系统
  + 准备：对静态变量赋予默认值
  + 解析：常量池中的符号引用转换成直接引用
+ 初始化：对静态变量赋予初始值

## 简述运行时数据区分配

+ 方法栈：栈型数据结构，存储的是方法中的局部变量表、临时变量、方法返回出口等。线程私有的
+ 本地方法栈：针对native方法的方法栈存储。
+ 程序计数器：记录程序运行的字节码文件的行号等
+ 堆：存储的是实例化的对象，数组等
+ 方法区：存储的是类的元数据，静态变量，JIT后的即时代码等

## 简述垃圾回收过程

垃圾收集算法：

引用计数法和可达性分析法

> 引用计数法：对象的引用在内存中开辟一块区域记录下来。被引用就+1，引用释放就-1。通过这个值的数量来判断当前对象是否还有用。问题在于会出现循环引用的情况，导致内存泄漏
>
> 可达性分析法：对一系列被称为GCRoots的根对象开始向下检索，一旦检索到就标注还在使用，最后将没有被检索到的对象释放掉。
> GCRoots的确立：
>
> + 虚拟机栈、本地方法栈中引用的对象（正在使用的对象）
> + 方法区/堆空间中静态属性引用的对象（说明使用频率会很高）
> + ...

强软弱虚引用类型，判断哪些引用是可回收的

强引用：即使当前没有引用链指向该对象，也不能回收

软引用：内存溢出之前的FullGC会将其回收

弱引用：下一轮垃圾回收的时候会被回收

虚引用：特殊存在，目的是在被回收的时候能够通知虚拟机一个状态。（发送系统通知）

垃圾回收算法：

> 标记-清除算法：一块内存空间的数据进行垃圾标记，标记结束之后，将属于垃圾的进行清楚（缺点是容易产生内存碎片）
>
> 复制算法：将一块内存空间的所有未被标记的数据复制到另外一个快内存空间。然后原本的内存空间全部回收（缺点是浪费空间）
>
> 标记-整理：先进行垃圾标记，清楚之后再对内存空间进行统一的整理，解决内存碎片化的问题（缺点是效率低下）
>
> 分代回收算法：
>
> 新生代使用**复制算法**
>
> 老年代使用**标记清楚**算法，一段时间之后进行一次**标记整理**
>
> ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/新生代垃圾回收.drawio.png)

## 简述各类垃圾回收器

回收年轻代的：SerialGC、ParallelGC、ParNewGC

回收老年代的：Serial Old GC、Parallel Old GC、CMS

都可以回收：G1

CMS：

> 并发标记清除。
>
> 先进性并发标记（和其他线程一起运行）
>
> 再重新标记（标记在上一轮运行的时候产生的垃圾，此时STW时间缩短）
>
> 再进行并发清除即可
>
> ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/hNpvy4.jpg)

G1：

> ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/G6Za7g.jpg)
>
> 将内存分配成多个小块空间。然后垃圾回收的时候可以指定每次回收的区域。从而降低垃圾回收造成的STW。同时可以实现多核CPU的性能问题





## 分代回收机制

1、将空间分为**新生代**和**老年代**。新生代分为一个Eden和两个Survivor区。

2、每次垃圾回收，将Eden和From中剩余的对象全部复制到Survivor的To中

3、对对象设置老年代计时器，超过计时器就复制到老年代中。

新生代使用复制算法

老年代使用标记清楚算法，时间长了之后进行依次标记整理解决碎片化问题



## MinorGC、MajorGC和FullGC

MinorGC（新生代）：正常GC，针对年轻代进行回收。Eden满了触发，将Eden和From复制到To中，STW

MajorGC（老年代）：老年代满了，进行老年代回收（一般在MinorGC之后），STW

FullGC（整堆及方法区）：进行MajorGC不能得到效果，进行整堆收集，包括方法区。

## G1的分区算法

G1在CMS的并发收集基础之上（也有并发标记和最终标记两部分）。将整个内存空间划分成同样大小的region（大对象使用多个连续的region存储）。每次清理只清理局部区域的内存空间。所以STW时间要较于CMS小

# 问题

## 什么是双亲委派机制



## 四种类加载器



## 如何自定义类加载器


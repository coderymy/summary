# 概念



## 简述类加载过程

+ 加载：将.class从硬盘上加载到内存中的过程
+ 连接
  + 验证：验证字节码文件是否合法且不会破坏系统
  + 准备：对静态变量赋予默认值
  + 解析：常量池中的符号引用转换成直接引用
+ 初始化：对静态变量赋予初始值

## 简述运行时数据区分配

+ 方法栈：栈型数据结构，存储的是方法中的局部变量表、临时变量、方法返回出口等。线程私有的
+ 本地方法栈：针对native方法的方法栈存储。
+ 程序计数器：记录程序运行的字节码文件的行号等
+ 堆：存储的是实例化的对象，数组等
+ 方法区：存储的是类的元数据，静态变量，JIT后的即时代码等

## 简述垃圾回收过程

垃圾收集算法：

引用计数法和可达性分析法

> 引用计数法：对象的引用在内存中开辟一块区域记录下来。被引用就+1，引用释放就-1。通过这个值的数量来判断当前对象是否还有用。问题在于会出现循环引用的情况，导致内存泄漏
>
> 可达性分析法：对一系列被称为GCRoots的根对象开始向下检索，一旦检索到就标注还在使用，最后将没有被检索到的对象释放掉。
> GCRoots的确立：
>
> + 虚拟机栈、本地方法栈中引用的对象（正在使用的对象）
> + 方法区/堆空间中静态属性引用的对象（说明使用频率会很高）
> + ...

强软弱虚引用类型，判断哪些引用是可回收的

强引用：即使当前没有引用链指向该对象，也不能回收

软引用：内存溢出之前的FullGC会将其回收

弱引用：下一轮垃圾回收的时候会被回收

虚引用：特殊存在，目的是在被回收的时候能够通知虚拟机一个状态。（发送系统通知）

垃圾回收算法：

> 标记-清除算法：一块内存空间的数据进行垃圾标记，标记结束之后，将属于垃圾的进行清楚（缺点是容易产生内存碎片）
>
> 复制算法：将一块内存空间的所有未被标记的数据复制到另外一个快内存空间。然后原本的内存空间全部回收（缺点是浪费空间）
>
> 标记-整理：先进行垃圾标记，清楚之后再对内存空间进行统一的整理，解决内存碎片化的问题（缺点是效率低下）
>
> 分代回收算法：
>
> 新生代使用**复制算法**
>
> 老年代使用**标记清楚**算法，一段时间之后进行一次**标记整理**
>
> ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/新生代垃圾回收.drawio.png)

## 简述各类垃圾回收器

回收年轻代的：SerialGC、ParallelGC、ParNewGC

回收老年代的：Serial Old GC、Parallel Old GC、CMS

都可以回收：G1

CMS：

> 并发标记清除。
>
> 先进性并发标记（和其他线程一起运行）
>
> 再重新标记（标记在上一轮运行的时候产生的垃圾，此时STW时间缩短）
>
> 再进行并发清除即可
>
> ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/hNpvy4.jpg)

G1：

> ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/G6Za7g.jpg)
>
> 将内存分配成多个小块空间。然后垃圾回收的时候可以指定每次回收的区域。从而降低垃圾回收造成的STW。同时可以实现多核CPU的性能问题





## 分代回收机制

1、将空间分为**新生代**和**老年代**。新生代分为一个Eden和两个Survivor区。

2、每次垃圾回收，将Eden和From中剩余的对象全部复制到Survivor的To中

3、对对象设置老年代计时器，超过计时器就复制到老年代中。

新生代使用复制算法

老年代使用标记清楚算法，时间长了之后进行依次标记整理解决碎片化问题



## MinorGC、MajorGC和FullGC

MinorGC（新生代）：正常GC，针对年轻代进行回收。Eden满了触发，将Eden和From复制到To中，STW

MajorGC（老年代）：老年代满了，进行老年代回收（一般在MinorGC之后），STW

FullGC（整堆及方法区）：进行MajorGC不能得到效果，进行整堆收集，包括方法区。

## G1的分区算法

G1在CMS的并发收集基础之上（也有并发标记和最终标记两部分）。将整个内存空间划分成同样大小的region（大对象使用多个连续的region存储）。每次清理只清理局部区域的内存空间。所以STW时间要较于CMS小



## JIT即时编译技术

将有价值的字节码编译成机器语言

**热点探测功能：**

使用计时器对**方法的使用频率和循环体的使用频率**进行统计。达到一定频率就开启JIT优化代码

**热点衰退：**

在对应优化的代码使用频率衰退到一定程度的时候，就关闭即时编译。

**编译器**

+ C1编译器：用在client模式上的java代码。耗时短（即时编译的代码少）对应代码运行速度差点。
+ C2编译器：用在server模式上的。耗时长（即时编译的代码多）对应代码运行速度可以。



---

---

---



# 问题

## 什么是双亲委派机制

从下往上判断是否加载过这个类。然后从上往下去尝试加载。

## 四种类加载器

+ Bootstrap类加载器，核心类加载器。加载rt.jar和其他加载器 
+ Ext类加载器，扩展类加载器
+ Application类加载器，应用类加载器
+ 自定义类加载器



## 如何自定义类加载器

1、继承`ClassLoader`接口，并实现其中的方法

2、实现方法的时候，指定加载类的路径，将加载进来的文件以类的形式返回即可

## 方法区、meta space、永久代的区别

1、jdk1.8之后，将方法区中的永久代替换成了元空间。且不在和堆内存连续而是使用本地内存空间。

2、在hotspot中方法区的实现是永久代/元空间。



## 关于字符串常量池

**版本问题：**

jdk1.6在永久代中

jdk1.7之后字符串常量池和静态变量的引用都被调整到了堆中

**什么是字符串常量池**

八种基本类型和String这种区分开

1、使用双引号创建的字符串，自动存放在字符串常量池中。使用对象new出来的放在堆中。可以使用.intern()方法

2、在1.7之前，使用双引号或者.intern()方法创建的字符串是放到了方法区中。但是之后全部都是在堆中，所以需要调整堆得大小。

### 类加载_三次破坏双亲委派机制

**<font color="red">第一次</font>**：**没有双亲委派机制之前**。JDK1.2之前有了ClassLoader的概念，但是没有双亲委派机制。这个时候的开发者如果已经有了一些自定义类加载器的代码就没法去强迫用户修改了。所以就只能妥协承认已出现的代码的破坏行为。

<font color="red">第二次</font>：**SPI机制**。基础接口的实现类，需要用户自己实现。比如Driver的实现类。所以这个时候本身Driver是BootStrap加载，但是需要用户自己的实现类。所以Bootstrap委托**上线文加载器**去通知应用类加载器，加载用户自己实现的实现类。

<font color="red">第三次</font>：**热替换，热部署**。每一个代码模块（Bundle）都有自己的类加载器。需要替换这个Bundle，就将其和其类加载器一起替换掉。重新加载的时候就不是从上至下的委托加载而是平行结构的直接加载。






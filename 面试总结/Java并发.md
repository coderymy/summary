# 概念

## 简述`synchronized`和`lock`的区别

1、synchronized关键字修饰方法或代码块，整个方法就会自动上锁解锁，异常自动解锁；lock需要手动调用lock()上锁和unlock()解锁。

2、synchronized是从字节码层面上加上了`monitorenter`和`monitorexit`，其使用的锁是对象的元数据上的`monitor`；lock使用比较灵活，使用的锁是传入lock的对象。

3、synchronized无法线程中断去执行别的线程（不灵活）



## 简述`synchronized`的实现原理

1、从字节码的层面将`monitorenter`和`monitorexit`加入进去包裹方法块。

2、基于对象的monitor锁，进行判断其值，每次进入锁+1，释放锁-1。直到其他线程观察这个锁为0才可以再进去。

## 简述volatile关键字

功能：多线程模式下去操作同一个变量，为了保证变量数据的变更能够在所有线程中实时共享。

工作原理：被volatile修饰的变量，在任何一个线程中进行了修改，都会通知主线程进行修改。其他线程（处理器）通过嗅探发现数据被修改，就会将自己本地的数据作废进行重新获取。

缺点：

1、不能保证原子性操作：只能保证共享变量在所有线程的可见性，但是不能保证顺序执行，也就是通知别的线程进行变更的底层操作不是原子性的。（通过加锁解决）

2、禁止了指令重排序（处理器对代码指令优化的一个功能）

## 简述线程池的几个参数

一共是七个（包括unit）

**`corePoolSize`**：空闲时间也会存在的最小线程数量，不会被回收的线程数量

**`maximumPoolSize`**：线程池允许的最大线程数量。当任务数量超过`corePoolSize`，就会将多余的任务加到队列中。如果队列也满了就会创建新的线程去处理业务。但是最大的线程数量就是`maximumPoolSize`。

**`keepAliveTime`**：取出`corePoolSize`之外的线程，在空闲这个时间之后就会销毁。（还有一个unit参数是给这个时间的单位）

**`workQueue`**：工作队列。当任务数量超过`corePoolSize`之后，多余的任务会放到工作队列中。

+ 有界阻塞队列：`Array`实现，当任务超过`corePoolSize`数量，放到该队列中的任务，如果任务数量超过了该队列的大小，就会创建新的线程去处理多余的任务。
+ 无界阻塞队列：`Linked`实现，该队列没有大小设置，只要多于`corePoolSize`处理的任务都会放在这个队列中等待。不会创建新的线程去处理
+ 不缓存阻塞队列：不会缓存任务，消费一个任务才能允许放入下一个任务（不会缓存任务等待线程）。超过`corePoolSize`会直接创建新线程去处理任务
+ 自定义优先级无界阻塞队列：实现`Comparator`接口，正常队列都是FIFO，但是这个队列可以修改任务的优先级。而且是无界的。

**`ThreadFactory`**：线程工厂，用来创建线程，同时指定线程名称、是否是Daemon线程（会随着主线程结束而强制结束）等属性。

**`handler`**：拒绝策略，工作队列满了且maximumPoolSize新线程的创建也到了上限。这个时候就根据这个策略配置来决定后面的任务如何处理

+ `AbortPolicy`丢弃任务并抛出异常。
+ `DiscardPolicy`丢弃任务不抛出异常。
+ `DiscardOldestPolicy`丢弃队列中最前面的任务，喜新厌旧。
+ `CallerRunsPolicy`由主线程去处理这些多余的任务。



## execute和submit开启线程池的区别

`execute`开启线程，没有返回结果（`runnable`类型任务）

`submit`会获取执行结果。所以可以用来执行`callable`对象。返回结果是一个Future对象（可以调用方法强制等待callable线程执行结束获取执行结果）

##  CAS原理

Compare and Swap，比较和交换

是什么：一种无锁方式实现线程之间变量同步的乐观锁实现。

存在的目的：为了缓解加锁导致的内核态和用户态频繁切换带来的效率损耗，同时实现乐观锁的业务需求。

实现原理：三个操作数，进行读写的值V、进行比较的值A、再次写入的值B。也就相当于CAS进行了一个循环等待

当B过来写入的时候，就会比较自己的持有A是否和现在存在的A是否相同。不相同就循环等待下一次写入。

```java
//含义就是下面的代码（啥也不是的代码）这个代码是原子的
public JNI Integer cas(int A,int B){
  if(A=v){
    v1=v;
    v=B;
    return v1;
  }else{
    A=V;
    return false;
  }
}
```

`AtomicInteger`就是基于`CAS`实现的线程安全的`Interger`。

## AQS原理

相当于对CAS的一种业务层面的封装

存在原因：

1、CAS只能关注一个int类型数据作为锁

2、CAS底层调用方法太复杂。不切合业务。





## 介绍你了解的各种锁

**乐观锁和悲观锁**

> **悲观锁**
>
> 每个线程对同一个资源进行操作的时候，都需要进行加锁，使用完资源之后释放锁。
>
> 优点：解决所有并发问题
>
> 缺点：不支持并发执行，效率很低
>
> **乐观锁**
>
> 对同一个数据操作的时候，记录一个版本号。每次进行修改的时候更新这个版本号。然后所有线程进行更新操作的时候都需要判断该版本号和第一次获取的时候的版本号是否一致

**自旋锁和自适应自旋锁**

> 自旋锁：不需要线程切换去等待别的线程释放锁，自己一直持有资源去循环判断锁是否释放
>
> 自适应自旋锁：自旋锁的优化，会判断自旋的次数来优化资源分配。

**无锁、偏向锁、轻量级锁、重量级锁**

> 四种锁在jdk1.6之后默认开启，锁的膨胀有对应的条件
>
> 无锁（直接放行）：没有对资源进行锁定，所有线程访问同一个资源。但是同时只有一个线程进行修改。循环修改的一种实现 CAS就是无锁
>
> **偏向锁（有吊牌）：当无锁竞争的情况下，一个线程获取了一次锁。下一次就不需要去尝试获取锁而是直接执行代码就好了。**（会修改对象头中的ThreadID为自己的ID）
>
> 轻量级锁（需要登记）：有一个线程访问偏向锁，偏向锁发现这个线程不是我等的那个线程，所以就将该锁进化成轻量级锁。其他线程需要进行自旋等待来尝试获取锁（多个线程的多次CAS）（门卫本来以为只有老王会来，结果来了老杨，就让后面来的都进行登记并且玩会手机等着老杨出来才能进入）
>
> 重量级锁（厕所关门）：就是遇到没有钥匙就得阻塞该线程，CPU切换到别的线程执行（门卫跟老杨说，今天只能老王进来，你明天再来吧）
>
> **四锁的关系**
>
> 这个过程可以称为锁的升级，也可以称为锁的膨胀
>
> ![](https://coderymy-image.oss-cn-beijing.aliyuncs.com/uPic/四级别锁.drawio.png)
>
> 只能正向升级，不能降级。
>
> `偏向锁`相对于`无锁`增加了**Mark Word**来标示锁
>
> `轻量级锁`相对于`偏向锁`增加了**自旋锁（适应性自旋锁）**操作来竞争锁
>
> `重量级锁`相对于`轻量级锁`增加了阻塞等待或者说悲观锁来实现

**公平锁和非公平锁**

> 公平锁，每个线程获取锁的结果是一样的，平均分配。
>
> 非公平锁，每个线程根据自己的执行效率和执行情况，每次获取锁的可能性不一样，随机分配。





# 小问题

## sleep和wait的区别

sleep会切换上下文，但是不会释放锁。

wait会释放锁让其他线程执行。

## start和run方法的区别

run方法是主线程去执行对应方法

start是新建线程去执行对应的方法

## 停止线程

1、Thread.stop，不安全不建议使用

2、this.Interrupt()，只是告诉线程执行到这就不执行了。

3、在run方法中标志位进行退出



## 线程间通信

1、volatile，关键字的线程共享来实现线程的通信。

2、join，一个线程调用了另外一个现成的join方法，就需要等待到对应线程执行结束才继续执行。可以通过这个来让线程顺序执行。

3、ThreadLocal，线程局部变量。也就是整个线程都可以获取整个ThreadLocal中的数据。不需要方法调用的时候携带。线程私有。

## 辅助类CountDownLatch和CyclicBarrier

CountDownLatch是计时器，数量上的线程达到了计时数量才允许继续执行主线程下去。

CyclicBarrier是循环栅栏。所有线程都到了一个状态，才继续一起执行下去

## 锁的膨胀

jdk1.6之后默认开启偏向锁。对象实例化之后，处于无锁状态，第一个线程调用了就会将对象头的ThreadID改成这个线程的id。然后变成了偏向锁，偏向这个对象。

第二个线程来访问，先去判断原本的线程是否还存在，如果不存在就变成无锁，然后再偏向新的线程。如果还存在就判断这个线程的操作数栈是否还需要使用到这个对象，还需要使用就升级成轻量级锁。开始竞争。并使用自旋等待的方式获取锁。

当有第三个线程来访问这个对象的时候，将轻量级锁进化成重量级锁（悲观锁）防止自旋浪费CPU资源


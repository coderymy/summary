# 概念

## Spring的事务机制

**原理**：基于AOP机制

1、对于被`@Transaction`修饰的Bean，会创建其代理对象

2、当调用代理对象的对应方法时，会先创建一个关闭了自动提交的数据库链接

3、执行该方法之前会开启事务，没有异常或异常是非捕捉回滚异常会自动提交事务。

**事务传播机制**

Spring事务自己实现的。对于配置的是新开一个事务而非进入原本的事务，会新建一个链接来开启新的事务。

① PROPAGATION_REQUIRED：（**默认传播行为**）如果当前没有事务，就创建一个新事务；如果当前存在事务，就加入该事务。
② PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。
③ PROPAGATION_SUPPORTS：如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。
④ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
⑤ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。
⑥ PROPAGATION_MANDATORY：如果当前存在事务，就加入该事务；如果当前不存在事务，就抛出异常。
⑦ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

**事务失效的原因**

+ 该方法的调用的对象，不是注入到IOC中的对象。Spring未管理
+ 异常抛出的时候没有被代理对象捕捉（自己内部捕捉处理或者配置的捕捉异常不匹配）
+ 没有开启配置事务管理器
+ Mysql本身不支持该事务



## Spring中的设计模式

1、代理模式：AOP机制、事务管理机制

2、工厂模式：BeanFactory

3、观察者模式：各种EventListener的实现类

4、单例模式：IOC容器中配置的单例属性

5、适配器模式：各种后处理器Aware方法等





## 循环依赖

使用多级缓存的方式来解决

一级缓存：放的是实例化结束后的Bean

二级缓存：放的是开始实例化的，但是未完成属性配置的Bean

三级缓存：用来生产二级缓存中对象的。存放创建的Bean实例的引用。

原理：A依赖B，B也依赖A

1、当要加载A的时候，实例化但是要注入B的属性值。这个时候可以将未完成依赖的A放入二级缓存中。开始初始化B

2、初始化B，当需要注入A的时候，去二级缓存中找到了A。然后注入成功，将B的实例化对象放到一级缓存中

3、给A注入B的属性，这个时候在一级缓存中找到了B。最终达到A中有B，B中有A



## 详述一下代理模式

**设计模式中的代理模式**

存在目的：

1、为了防止直接使用对象带来不可预知的问题

2、增强对象

简单的代码实现逻辑

1、对象A有对应方法a

2、代理对象AProxy，有对应方法aProxy，其中调用a方法

3、调用a方法不再创建A对象。而是创建AProxy，来调用aProxy方法



**静态代理和动态代理**

本质区别：

1、静态代理是代理模式的一种代码实现。动态代理只是用了代理模式的思想

2、动态代理不需要去对每一个代理对象实现具体的代理类。而是统一交给动态代理方法去管理

**jdk动态代理和CGLib动态代理**

**底层实现原理区别：**

+ JDK动态代理是基于java内部的反射机制来生成对应的代理类
+ CGLib是基于asm包在字节码层面生成代理类来实现方法的增强

**使用上的区别**

1、JDK动态代理要求，代理类和代理对象实现同一个接口；CGLib不需要实现同一个接口。

2、JDK动态代理依赖InvocationHandler来创建代理类；CGLib依赖MethodIntercepter对象来创建代理类。

**SpringAOP在使用动态代理的时候**

能用JDK动态代理（代理对象有接口（能让代理类实现对应的接口））就用，否则就用CGLib。

**AOP除了代理方式**

AspectJ插件，帮助在编译阶段将通知的业务代码切入到切点中去。这样就可以不用生成代理类来帮助实现。

## SpringBean的生命周期

实例化、属性注入、初始化、销毁

1、实例化：通过反射机制创建对应的对象

2、属性注入：对实例化的对象中需要的属性进行注入，如果依赖未创建的Bean就先去创建对应的Bean

3、初始化：执行一些Bean的后处理器。

4、销毁：不受依赖的时候进行销毁。销毁前也会执行一些后处理器





